<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to my blog</title>
    <url>/2024/06/29/IntroduceMyself/</url>
    <content><![CDATA[<p>致力于Java全栈开发，分享相关知识</p>
]]></content>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2024/07/01/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1.Docker概述"></a>1.Docker概述</h2><p>Docker的思想来源于集装箱！</p>
<p>JRE –多个应用 （端口冲突） –原来都是交叉的！</p>
<p>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的</p>
<h3 id="1-1Docker能做什么"><a href="#1-1Docker能做什么" class="headerlink" title="1.1Docker能做什么"></a>1.1Docker能做什么</h3><blockquote>
<p>容器化技术：容器化技术不是模拟的一个完整的操作系统</p>
</blockquote>
<p>比较Docker和虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内容，容器时是没有自己内核的</li>
<li>每个容器内是互相隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<span id="more"></span>

<blockquote>
<p>DevOps(开发，运维)</p>
</blockquote>
<p><strong>更快速地交付和部署</strong></p>
<p>Docker：打包镜像，发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用了 Docker之后，我们部署应用就和搭积木一样</p>
<p>项目打包为一个镜像，扩展服务器A！服务器B</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，我们的开发，测试环境都是高度一致的</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨</p>
<p>到极致。</p>
<h3 id="1-2Docker基本组成"><a href="#1-2Docker基本组成" class="headerlink" title="1.2Docker基本组成"></a>1.2Docker基本组成</h3><p><strong>镜像（images）</strong>：</p>
<p>docker镜像就好比一个模板，可以通过这个模板来创建容器服务，</p>
<p>例如：tomcat镜像&#x3D;&#x3D;&#x3D;&gt;run &#x3D;&#x3D;&gt;tomcat01容器(提供服务器)</p>
<p>通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中）</p>
<p><strong>容器（container）</strong>：</p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的</p>
<p>容器可以启动，停止，删除等基本命令</p>
<p>目前可以把这个容器理解为一个简易的Linux系统，</p>
<p><strong>仓库（repository）</strong>：</p>
<p>仓库就是存放镜像的地方</p>
<p>仓库分为公有仓库和私有仓库</p>
<h3 id="1-3回顾Docker-helloworld流程"><a href="#1-3回顾Docker-helloworld流程" class="headerlink" title="1.3回顾Docker helloworld流程"></a>1.3回顾Docker helloworld流程</h3><p>1.run的运行流程图</p>
<p><img src="https://www.freeimg.cn/i/2024/05/08/663b99472e6d7.jpg" alt="https://www.freeimg.cn/i/2024/05/08/663b99472e6d7.jpg"></p>
<h3 id="1-4底层原理"><a href="#1-4底层原理" class="headerlink" title="1.4底层原理"></a>1.4底层原理</h3><p><strong>Docker是怎么工作的？</strong></p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问</p>
<p>DockerServer接收到Docker-Client的指令，就会执行这个命令</p>
<p><img src="https://www.freeimg.cn/i/2024/05/09/663c3667ac2ad.jpg" alt="https://www.freeimg.cn/i/2024/05/09/663c3667ac2ad.jpg"></p>
<h2 id="2-Docker的基本命令"><a href="#2-Docker的基本命令" class="headerlink" title="2.Docker的基本命令"></a>2.Docker的基本命令</h2><h3 id="2-1帮助命令"><a href="#2-1帮助命令" class="headerlink" title="2.1帮助命令"></a>2.1帮助命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version #查看版本信息</span><br><span class="line">docker info    #查看docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker  命令  --help  #帮助命令</span><br></pre></td></tr></table></figure>

<h3 id="2-2-镜像命令"><a href="#2-2-镜像命令" class="headerlink" title="2.2 镜像命令"></a>2.2 镜像命令</h3><p><strong>docker images</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng /]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    d2c94e258dcb   12 months ago   13.3kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY  镜像的仓库源</span><br><span class="line">TAG 		镜像的标签</span><br><span class="line">IMAGE ID	镜像的id</span><br><span class="line">CREATED		镜像创建的时间</span><br><span class="line">SIZE		镜像的大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可选项</span></span><br><span class="line">-a, --all             	#列出所有镜像</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Format output using a custom template:</span><br><span class="line">                        &#x27;table&#x27;:            Print output in table format with column headers (default)</span><br><span class="line">                        &#x27;table TEMPLATE&#x27;:   Print output in table format using the given Go template</span><br><span class="line">                        &#x27;json&#x27;:             Print in JSON format</span><br><span class="line">                        &#x27;TEMPLATE&#x27;:         Print output using the given Go template.</span><br><span class="line">                        Refer to https://docs.docker.com/go/formatting/ for more information about formatting output with templates</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet           #只显示镜像的id</span><br></pre></td></tr></table></figure>



<p><strong>docker search   搜索镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng ~]# docker search mysql</span><br><span class="line">NAME                            DESCRIPTION                                     STARS     OFFICIAL</span><br><span class="line">mariadb                         MariaDB Server is a high performing open sou…   5722      [OK]</span><br><span class="line">mysql                           MySQL is a widely used, open-source relation…   15008     [OK]</span><br><span class="line">percona                         Percona Server is a fork of the MySQL relati…   627       [OK]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可选项</span>   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过收藏来过滤   --filter=StARS=3000  搜索3000以上收藏的</span></span><br></pre></td></tr></table></figure>



<p><strong>docker pull  下载镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载镜像   docker pull 镜像名[:tag]</span></span><br><span class="line">[root@wpeng ~]# docker pull mysql</span><br><span class="line">Using default tag: latest   #如果不写tag，默认就是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">0f6737e7f918: Pull complete   #分层下载   docker image的核心  联合文件系统</span><br><span class="line">43ed19546d51: Pull complete </span><br><span class="line">501aa8e883de: Pull complete </span><br><span class="line">530c0b888a0f: Pull complete </span><br><span class="line">4670b7e1bbfd: Pull complete </span><br><span class="line">33d50b789abe: Pull complete </span><br><span class="line">7cd9fbae13f7: Pull complete </span><br><span class="line">34b7592f6de1: Pull complete </span><br><span class="line">6795b8ab791a: Pull complete </span><br><span class="line">09cffac37cee: Pull complete </span><br><span class="line">Digest: sha256:e4054c2973be8766370769312786404fbb4557fb591d9ad37beb2d00a2c574a6  #签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest	#真实地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以上命令等价于下方命令</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定版本下载</span></span><br><span class="line">docker pull mysql:8.0.20</span><br></pre></td></tr></table></figure>



<p><strong>docker rmi  删除镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng ~]#docker rmi -f 镜像id #删除指定的镜像</span><br><span class="line">[root@wpeng ~]#docker rmi -f 镜像id 镜像id 镜像id 镜像id#删除指定的镜像</span><br><span class="line">[root@wpeng ~]#docker rmi -f $(docker images -aq) #删除全部的镜像</span><br></pre></td></tr></table></figure>



<h3 id="2-3-容器命令"><a href="#2-3-容器命令" class="headerlink" title="2.3 容器命令"></a>2.3 容器命令</h3><p><strong>说明：我们有了镜像才可以创建容器  下一个alibaba cloud linux3镜像测试学习</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull alibaba-cloud-linux-3-registry.cn-hangzhou.cr.aliyuncs.com/alinux3/alinux3:220901.1</span><br></pre></td></tr></table></figure>

<p>上述是下载杭州节点的镜像</p>
<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;  容器名字   tomcat01  tomcat02  起不同的名字用来区别不同的容器</span><br><span class="line">-d    		   后台方式运行</span><br><span class="line">-p			   指定容器的端口  -p  8080:8080   -p 主机端口:容器端口(常用的)   -p 容器端口</span><br><span class="line">-P			   随机指定端口</span><br><span class="line">-it 		   使用交互方式运行，进入容器查看内容</span><br><span class="line"></span><br><span class="line">[root@wpeng ~]# docker run -it 镜像名或者镜像id /bin/bash</span><br><span class="line"></span><br><span class="line">bash-4.4# ls  查看容器内的alibabalinux</span><br><span class="line">bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p><strong>列出所有运行中的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker ps</span>  </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">列出当前正在运行的容器</span></span><br><span class="line">-a	#列出当前正在运行的容器+历史运行过的容器</span><br><span class="line">-n=?	#显示最近创建的容器  ？是数字  n=1就是显示最近一个创建的容器</span><br><span class="line">-q #只显示容器的编号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@wpeng /]# docker ps        列出正在运行的容器，这里没有容器在运行，所以没有查处结果</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@wpeng /]# docker ps -a	 加一个-a参数，列出现在以及历史运行的容器</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                          PORTS     NAMES</span><br><span class="line">6800a5514ec0   c54f2e68b09f   &quot;/bin/bash&quot;   4 minutes ago   Exited (0) About a minute ago             sharp_lovelace</span><br><span class="line">77307f9c5e0b   hello-world    &quot;/hello&quot;      25 hours ago    Exited (0) 25 hours ago                   adoring_rubin</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit  #直接容器停止并退出</span><br><span class="line">ctrl +P +Q  #容器不停止退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id					#删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line">docker rm -f  $(docker ps -aq)   #删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  #删除所有的容器</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id		#启动容器</span><br><span class="line">docker restart 容器id		#重启容器</span><br><span class="line">docker stop  容器id		#停止当前正在运行的容器</span><br><span class="line">docker kill  容器id		#强制停止当前容器</span><br></pre></td></tr></table></figure>

<h3 id="2-4常用其他命令"><a href="#2-4常用其他命令" class="headerlink" title="2.4常用其他命令"></a>2.4常用其他命令</h3><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 镜像名或者镜像id</span><br><span class="line">root@wpeng ~]# docker run -d c54f2e68b09f</span><br><span class="line">f589d68fae5ef55b40a0cb27cafb767069e941bf1b046cda87a8a23f3e41f308</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">出现了问题，发现镜像停止了</span></span><br><span class="line">[root@wpeng ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例如，docker启动nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs  -tf --tail number 容器id #显示number条的日志</span><br><span class="line">docker logs -tf  容器id     #显示所有日志</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示日志</span></span><br><span class="line">-tf   #显示日志   </span><br><span class="line">		-t:timestamps 表示在输出的日志中包含时间戳</span><br><span class="line">		-f：意味着持续跟进（follow）日志输出</span><br></pre></td></tr></table></figure>

<p><strong>查看容器中进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br><span class="line"></span><br><span class="line">[root@wpeng ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED       STATUS       PORTS     NAMES</span><br><span class="line">b049032b93eb   c54f2e68b09f   &quot;/bin/bash&quot;   4 hours ago   Up 4 hours             vigilant_spence</span><br><span class="line">[root@wpeng ~]# docker top b049032b93eb</span><br><span class="line">UID             PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                60523               60502               0                   12:49               pts/0               00:00:00            /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>查看镜像的元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试</span></span><br><span class="line">[root@wpeng ~]# docker inspect b049032b93eb</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;b049032b93ebf228dabc3f842ee475b9705fbd9a352a10052353faab52a101a8&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2024-05-10T04:49:41.711491571Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">        &quot;Args&quot;: [],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 60523,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2024-05-10T04:49:41.915405566Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:c54f2e68b09f57d742dee837edd20ca37b9fd052f8d1456b2b0777c0046528d0&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/b049032b93ebf228dabc3f842ee475b9705fbd9a352a10052353faab52a101a8/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/b049032b93ebf228dabc3f842ee475b9705fbd9a352a10052353faab52a101a8/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/b049032b93ebf228dabc3f842ee475b9705fbd9a352a10052353faab52a101a8/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/b049032b93ebf228dabc3f842ee475b9705fbd9a352a10052353faab52a101a8/b049032b93ebf228dabc3f842ee475b9705fbd9a352a10052353faab52a101a8-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/vigilant_spence&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;bridge&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                41,</span><br><span class="line">                187</span><br><span class="line">            ],</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: [],</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: [],</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;,</span><br><span class="line">                &quot;/sys/devices/virtual/powercap&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/9bb0667c3640a03ae8bbb2d698bc030fd5e9a5027d48c0fa48f42bf607472496-init/diff:/var/lib/docker/overlay2/4fabcb33a99857d5f701a9d733a0407faef4f760993cf19c5cca603c16dc27f5/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/9bb0667c3640a03ae8bbb2d698bc030fd5e9a5027d48c0fa48f42bf607472496/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/9bb0667c3640a03ae8bbb2d698bc030fd5e9a5027d48c0fa48f42bf607472496/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/9bb0667c3640a03ae8bbb2d698bc030fd5e9a5027d48c0fa48f42bf607472496/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;b049032b93eb&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: true,</span><br><span class="line">            &quot;AttachStdout&quot;: true,</span><br><span class="line">            &quot;AttachStderr&quot;: true,</span><br><span class="line">            &quot;Tty&quot;: true,</span><br><span class="line">            &quot;OpenStdin&quot;: true,</span><br><span class="line">            &quot;StdinOnce&quot;: true,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/bash&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;c54f2e68b09f&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;/&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20220830&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;Alinux3 Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;Alibaba Cloud&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;5093b0c24d349da1366a160ccf8a6b34453e48241c3739973897cd53eaffbaf7&quot;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/5093b0c24d34&quot;,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;3ba3f966c5fe8dffcc94466187ac59bf8367236a889abc542f412647c4e29b6d&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;4888153fb4139c358ffdff11975f7acf918721ae5725a8f06e6687a53668279e&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;3ba3f966c5fe8dffcc94466187ac59bf8367236a889abc542f412647c4e29b6d&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;DriverOpts&quot;: null,</span><br><span class="line">                    &quot;DNSNames&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们通常容器都是使用后台方式进行的，需要进入容器，需要修改一些配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令</span> </span><br><span class="line">docker exec -it  容器id  /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line">正在执行当前的代码</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">二者的区别</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">docker <span class="built_in">exec</span>  进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">docker attach 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径  目的主机路径</span><br><span class="line"></span><br><span class="line">[root@wpeng home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">52b9662ad370   c54f2e68b09f   &quot;/bin/bash&quot;   52 minutes ago   Up 52 minutes             elated_khayyam</span><br><span class="line">[root@wpeng home]# docker attach 52b9662ad370</span><br><span class="line">bash-4.4# cd /home</span><br><span class="line">bash-4.4# ls</span><br><span class="line">bash-4.4# touch test.java</span><br><span class="line">bash-4.4# ls</span><br><span class="line">test.java</span><br><span class="line">bash-4.4# read escape sequence</span><br><span class="line">[root@wpeng home]# docker cp 52b9662ad370:/home/test.java /home</span><br><span class="line">Successfully copied 1.54kB to /home</span><br><span class="line">[root@wpeng home]# ls</span><br><span class="line">Mytest  test.java  wpeng</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝是一个手动过程  未来我们使用-v卷的技术，可以实现打通主机与容器  例如主机下的/home目录和容器内的/home目录同步</span>    </span><br></pre></td></tr></table></figure>

<h2 id="3-作业练习"><a href="#3-作业练习" class="headerlink" title="3.作业练习"></a>3.作业练习</h2><blockquote>
<p>Docker安装nginx</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.搜索镜像  docker search 镜像名字</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.下载镜像  docker pull 镜像名字</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行 --name nginx01  起别名为nginx01  -p 3344:80  主机端口，容器端口 内部端口是80，但是外网访问的是3344端口</span></span><br><span class="line">[root@wpeng /]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">29d82b8d3586f8e8831756410d90ef5ba31561460790da6b3bc9b80d0ddb706a</span><br><span class="line">[root@wpeng /]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED             STATUS             PORTS                                   NAMES</span><br><span class="line">29d82b8d3586   nginx          &quot;/docker-entrypoint.…&quot;   8 seconds ago       Up 7 seconds       0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Docker安装tomcat</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">官方使用</span>  </span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们之前的启动都是后台，停止了容器之后，容器还是可以查到   docker run -it --<span class="built_in">rm</span> 一般用来测试，用完即删除</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载再启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动运行</span></span><br><span class="line">[root@wpeng ~]# docker run -d --name tomcat01 tomcat</span><br><span class="line">abe42510023f787c38cfe38bc5ed99ae88e78baa479be84223e9aef21e177af8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Docker部署es+kibana</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">es  暴露的端口很多</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">es  十分的耗内存</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">es 的数据一般需要放置到安全目录！挂载</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动 elasticsearch</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:版本号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--net somenetwork 网络配置</span></span><br></pre></td></tr></table></figure>

<h2 id="4-可视化"><a href="#4-可视化" class="headerlink" title="4.可视化"></a>4.可视化</h2><h3 id="4-1portainer"><a href="#4-1portainer" class="headerlink" title="4.1portainer"></a><strong>4.1portainer</strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询当前有哪些Portainer镜像</span></span><br><span class="line">docker search portainer</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行portainerUI图形界面</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d后台运行 --name 命名 -p 端口映射(需要确认端口号是开放的) -v挂载(后面博客详说)</span></span><br><span class="line">docker run -d --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -restart=always --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>什么是portainer？</p>
<p>Docker图形化界面管理工具！提供一个后台面板供我们操作</p>
<p><strong>Rancher</strong></p>
<h2 id="5-Docker镜像讲解"><a href="#5-Docker镜像讲解" class="headerlink" title="5.Docker镜像讲解"></a>5.Docker镜像讲解</h2><h3 id="5-1镜像是什么"><a href="#5-1镜像是什么" class="headerlink" title="5.1镜像是什么"></a><strong>5.1镜像是什么</strong></h3><p>镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时，库，环境变量和配置文件</p>
<p>所有的应用，直接打包成一个docker镜像，就可以直接跑起来</p>
<p>如何得到镜像呢</p>
<ul>
<li>从远程仓库下载</li>
<li>别人拷贝给你</li>
<li>自己制作一个镜像 docker file</li>
</ul>
<h3 id="5-2Docker镜像加载原理"><a href="#5-2Docker镜像加载原理" class="headerlink" title="5.2Docker镜像加载原理"></a>5.2Docker镜像加载原理</h3><blockquote>
<p>UnionFs （联合文件系统）</p>
</blockquote>
<p>我们下载的时候看到一层层的下载就是这个。</p>
<p>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支</p>
<p>持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（</p>
<p>unite several directories into a single virtual filesystem)。Union文件系统是</p>
<p>Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应</p>
<p>用镜像。</p>
<p><strong>特性</strong>：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系</p>
<p>统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="5-3分层理解"><a href="#5-3分层理解" class="headerlink" title="5.3分层理解"></a>5.3分层理解</h3><p><a href="https://blog.csdn.net/weixin_46618592/article/details/126555359">https://blog.csdn.net/weixin_46618592/article/details/126555359</a></p>
<p><img src="https://www.freeimg.cn/i/2024/05/11/663f920212692.jpg" alt="https://www.freeimg.cn/i/2024/05/11/663f920212692.jpg"></p>
<h3 id="5-4-commit镜像"><a href="#5-4-commit镜像" class="headerlink" title="5.4  commit镜像"></a>5.4  commit镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit  提交容器成为一个新的副本</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令和git原理相似</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id  目标镜像名:[tag]</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>实战测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动一个默认的tomcat</span></span><br><span class="line">docker exec -it 5a2a89b5dd88 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发现这个默认的tomcat是没有webapps应用，  镜像的原因，官方的镜像默认webapps下面是没有文件的</span></span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat# cd webapps</span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat/webapps# ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我自己拷贝进去了基本的文件</span></span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat# cd webapps.dist/</span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat/webapps.dist# ls</span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br><span class="line"></span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat# cp -r  webapps.dist/* webapps</span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat# cd webapps</span><br><span class="line">root@5a2a89b5dd88:/usr/local/tomcat/webapps# ls</span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>添加镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng /]docker ps        </span><br><span class="line">CONTAINER ID   IMAGE                 COMMAND             CREATED          STATUS          PORTS                                                           NAMES</span><br><span class="line">5a2a89b5dd88   tomcat                &quot;catalina.sh run&quot;   12 minutes ago   Up 12 minutes   8080/tcp                                                        unruffled_visvesvaraya</span><br><span class="line">af1186a6d300   portainer/portainer   &quot;/portainer&quot;        40 hours ago     Up 40 hours     8000/tcp, 9443/tcp, 0.0.0.0:9000-&gt;9000/tcp, :::9000-&gt;9000/tcp   portainerUI</span><br><span class="line"></span><br><span class="line">[root@wpeng /]# docker commit  -a=&quot;wpeng&quot; -m=&quot;add webapps application&quot; 5a2a89b5dd88 tomcat02:1.0</span><br><span class="line">sha256:e337f0c3d17aacf7cc88a4ab64c31f8574703310f73c59f36d441f8bd69fd30d</span><br><span class="line">[root@wpeng /]# docker images</span><br><span class="line">REPOSITORY                                                                   TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">tomcat02                                                                     1.0        e337f0c3d17a   5 seconds ago   460MB</span><br><span class="line">nginx                                                                        latest     1d668e06f1e5   9 days ago      188MB</span><br><span class="line">tomcat                                                                       latest     fca42eb4b550   10 days ago     455MB</span><br><span class="line">mysql                                                                        latest     f3df03e3cfc9   11 days ago     585MB</span><br><span class="line">hello-world                                                                  latest     d2c94e258dcb   12 months ago   13.3kB</span><br><span class="line">portainer/portainer                                                          latest     5f11582196a4   17 months ago   287MB</span><br><span class="line">alibaba-cloud-linux-3-registry.cn-hangzhou.cr.aliyuncs.com/alinux3/alinux3   220901.1   c54f2e68b09f   20 months ago   162MB</span><br><span class="line">elasticsearch                                                                7.6.2      f29a1ee41030   4 years ago     791MB</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">tomcat02就是我们自己修改过的镜像，以后使用我们自己的镜像</span></span><br></pre></td></tr></table></figure>



<h2 id="6-容器数据卷"><a href="#6-容器数据卷" class="headerlink" title="6.容器数据卷"></a>6.容器数据卷</h2><h3 id="6-1什么是容器数据卷"><a href="#6-1什么是容器数据卷" class="headerlink" title="6.1什么是容器数据卷"></a>6.1什么是容器数据卷</h3><p><strong>docker理念回顾</strong>、</p>
<p>将应用和环境打包成一个镜像</p>
<p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！&#x3D;&#x3D;需求：数据可以持久化&#x3D;&#x3D;</p>
<p>Mysql，容器删除了数据就会丢失！&#x3D;&#x3D;需求：Mysql数据可以存储在本地&#x3D;&#x3D;</p>
<p>容器之间可以有一个数据共享技术！Docker容器中产生的数据，同步到本地</p>
<p>这就是卷技术!   目录的挂载，将我们容器内的目录，挂载到Linux上面</p>
<p><img src="https://www.freeimg.cn/i/2024/05/13/6641b5ba591ae.jpg" alt="https://www.freeimg.cn/i/2024/05/13/6641b5ba591ae.jpg"></p>
<p>总结一句话：<strong>容器的持久化和同步操作！容器之间的数据也是可以共享的</strong></p>
<h3 id="6-2使用数据卷"><a href="#6-2使用数据卷" class="headerlink" title="6.2使用数据卷"></a>6.2使用数据卷</h3><blockquote>
<p>方式一：直接使用命令   -v  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng home]# docker run -it -v /home/ceshi:/home tomcat /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动起来之后，可以通过docker inspect 容器<span class="built_in">id</span>   查看容器的元数据，可以找到下方的挂载</span></span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">              &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">              &quot;Source&quot;: &quot;/home/ceshi&quot;,    #主机内的目录</span><br><span class="line">              &quot;Destination&quot;: &quot;/home&quot;,		#容器内的目录</span><br><span class="line">              &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">              &quot;RW&quot;: true,</span><br><span class="line">              &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br></pre></td></tr></table></figure>

<h3 id="6-3实战：部署Mysql"><a href="#6-3实战：部署Mysql" class="headerlink" title="6.3实战：部署Mysql"></a>6.3实战：部署Mysql</h3><p>思考：mysql的数据持久化问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng /]# docker run -d -p 3307:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=Mypasseord --name mysql01 mysql</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂机到本地</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4具名和匿名挂载"><a href="#6-4具名和匿名挂载" class="headerlink" title="6.4具名和匿名挂载"></a>6.4具名和匿名挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匿名挂载</span></span><br><span class="line">-v  容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx  nginx</span><br><span class="line"></span><br><span class="line">[root@wpeng data]# docker volume --help</span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br><span class="line"></span><br><span class="line">Run &#x27;docker volume COMMAND --help&#x27; for more information on a command.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有卷的情况</span></span><br><span class="line">[root@wpeng data]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     09ed66408d0ea4f3cede2deb02050a0bada25b157888fcda3f1166fea9270c8b</span><br><span class="line">local     36c362bddff71830d36d3a6c32aee9b7a8c8f486d1bcc33e0281e77c9b22b579</span><br><span class="line">local     125b1bde7fa779c129b710c6b2a3d5295c6e1073bad17a53fe1484355d19022e</span><br><span class="line">local     03027f475b79a21b49b0ca7c6950f333151c6cc1f35f0f1735b4d2572ef9ae08</span><br><span class="line">local     959225beaef8d8194aed30d2c96ecb1199b73f5be6e2cd9547d3696ecf90f13b</span><br><span class="line">local     b7016e08f4d6e6cd186815c6778a7831be7e43ba48ea9f0eb370bb756388ee6c</span><br><span class="line">local     ccf907023afe4669577ce46e75b403bbe30f8ed3fdb53e7be3c22e0de57a8680</span><br><span class="line">local     d7b8b4150ebc6d374d39ac8d35e2f598cafd7b8bdb2c44a3f77e3cef09537df1</span><br><span class="line">local     dbb2225560dd9c26105084169118989d03176d98fcc0490246155d820950c684</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>具名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v  容器内路径    	#匿名挂载</span><br><span class="line">-v  卷名:容器内路径  #具名挂载</span><br><span class="line">-v  /宿主机路径:容器内路径 #指定路径挂载</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过 -v 容器内路径:ro rw 改变读写权限</span></span><br><span class="line">ro   readonly    #只读</span><br><span class="line">rw	 readwrite	 #读写</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro rw nginx</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro rw nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内是无法操作的</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5初始Dockerfile"><a href="#6-5初始Dockerfile" class="headerlink" title="6.5初始Dockerfile"></a>6.5初始Dockerfile</h3><p>dockerfile就是用来构建docker镜像的构建文件！命令脚本</p>
<p>通过这个脚本可以生成一个镜像，镜像是一层一层的，脚本是一个一个命令  每个命令都是一层</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;-----end-----&quot;</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上述的命令，就是镜像的一层</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f /home/docker-test-volume/dockerfile -t wpeng/centos:1.0 .</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;复制粘贴时，小心细节，结尾一定要加空格再加点&#x3D;&#x3D;。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动自己生成的容器</span></span><br><span class="line">[root@wpeng ~]# docker run -it 9b5949716ba8 /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="built_in">ls</span>命令，查看目录发现两个挂载的目录</span></span><br><span class="line">drwxr-xr-x   2 root root 4096 May 14 02:38 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 14 02:38 volume02</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;发现了这两个卷，说明外部一定有同步的目录&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用inspect命令查看镜像元数据</span></span><br><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<p><img src="https://www.freeimg.cn/i/2024/05/14/6642d5b191c27.png" alt="https://www.freeimg.cn/i/2024/05/14/6642d5b191c27.png"></p>
<p><strong>在mounts下可以找到容器内挂载目录在宿主机上对应的目录，就是source目录</strong></p>
<p>在宿主机下找到这个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng /]# cd /var/lib/docker/volumes/d4a1b49ca6e2b10dde089f27d7ef5459b5b7e03aed4f42fbbea05961131f22e5/_data</span><br><span class="line">[root@wpeng _data]# ls</span><br><span class="line">container.txt</span><br></pre></td></tr></table></figure>

<p>可以看到该目录下有一个container.txt</p>
<h3 id="6-6数据卷容器"><a href="#6-6数据卷容器" class="headerlink" title="6.6数据卷容器"></a>6.6数据卷容器</h3><p><strong>多个mysql同步数据</strong></p>
<p><img src="https://www.freeimg.cn/i/2024/05/13/66422773b10ff.jpg" alt="https://www.freeimg.cn/i/2024/05/13/66422773b10ff.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先启动一个容器</span></span><br><span class="line">[root@wpeng /]# docker run -it --name docker01 wpeng/centos:1.0 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再启动一个容器，父容器是docker01</span></span><br><span class="line">[root@wpeng /]# docker run -it --name docker02 --volumes-from docker01 wpeng/centos:1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在docker01容器中创建一个container.txt</span></span><br><span class="line">[root@wpeng ~]# docker exec -it 1440424683e5 /bin/bash</span><br><span class="line">[root@1440424683e5 /]# ls    </span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line">[root@1440424683e5 /]# cd volume01</span><br><span class="line">[root@1440424683e5 volume01]# ls</span><br><span class="line">[root@1440424683e5 volume01]# touch container.txt</span><br><span class="line">[root@1440424683e5 volume01]# ls</span><br><span class="line">container.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发现在docker02容器中也发现了container.txt</span></span><br><span class="line">[root@wpeng ~]# docker run -it --name docker02 --volumes-from docker01 9b5949716ba8</span><br><span class="line">[root@cc09ccf13df0 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02</span><br><span class="line">[root@cc09ccf13df0 /]# cd volume01</span><br><span class="line">[root@cc09ccf13df0 volume01]# ls</span><br><span class="line">container.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;上述容器docker02依赖于docker01，执行删除docker01容器之后，docker02里面的数据还是存在的，实现了共享与备份&#x3D;&#x3D;</p>
<p><strong>多个mysql实现数据共享</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng /]# docker run -d -p 3307:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=Mypassword --name mysql01 mysql</span><br><span class="line"></span><br><span class="line">[root@wpeng /]# docker run -d -p 3308:3306  -e MYSQL_ROOT_PASSWORD=Mypassword --name mysql02 --volumes -from mysql01 mysql </span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</p>
<p>但是你一旦持久化到本地，这个时候，本地的数据是不会删除的</p>
<h2 id="7-DockerFile"><a href="#7-DockerFile" class="headerlink" title="7.DockerFile"></a>7.DockerFile</h2><h3 id="7-1DockerFile介绍"><a href="#7-1DockerFile介绍" class="headerlink" title="7.1DockerFile介绍"></a>7.1DockerFile介绍</h3><p><strong>dockerfile是用来构建docker镜像的文件，就是命令参数脚本</strong></p>
<p>很多官方镜像都是基础包，很多功能没有，我们通常会搭建自己的镜像</p>
<p>构建步骤：</p>
<ol>
<li>编写一个dockerfile文件</li>
<li>docker build 一个镜像</li>
<li>docker run 运行镜像</li>
<li>通过docker push 发布镜像（DockerHub，阿里云镜像仓库）</li>
</ol>
<h3 id="7-2DockerFile构建过程"><a href="#7-2DockerFile构建过程" class="headerlink" title="7.2DockerFile构建过程"></a>7.2DockerFile构建过程</h3><p><strong>基础知识</strong></p>
<ol>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行从上到下顺序执行</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交<img src="https://www.freeimg.cn/i/2024/05/14/66433726dd7a8.jpg" alt="https://www.freeimg.cn/i/2024/05/14/66433726dd7a8.jpg"></li>
</ol>
<p>dockerfile是面向开发的，我们以后要发布项目，就需要编写dockerfile文件，这个文件是十分简单</p>
<p>DockerFile：构建文件。定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockeFile构建生成的镜像，最终发布和运行的产品</p>
<p>Docker容器：容器就是为镜像运行起来提供服务的</p>
<h3 id="7-3DockerFile的指令"><a href="#7-3DockerFile的指令" class="headerlink" title="7.3DockerFile的指令"></a>7.3DockerFile的指令</h3><p><img src="https://www.freeimg.cn/i/2024/05/14/664339d6b8a72.png" alt="https://www.freeimg.cn/i/2024/05/14/664339d6b8a72.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM		#基础镜像，一切从这里构建</span><br><span class="line">MAINTAINER  #镜像的作者，一般姓名+邮箱</span><br><span class="line">RUN			#镜像构建的时候需要运行的命令</span><br><span class="line">ADD			#步骤：如果需要添加tomcat镜像，则需要tomcat压缩包！添加内容</span><br><span class="line">WORKDIR		#镜像的工作目录  </span><br><span class="line">VOLUME		#挂载的目录位置</span><br><span class="line">EXPOSE		#暴露端口配置   和-p是一个作用，如果expose了就不需要-p暴露端口了</span><br><span class="line">CMD			#指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT  #指定这个容器启动的时候要运行的命令，可以直接追加命令</span><br><span class="line">ONBUILD     #当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令，触发指令</span><br><span class="line">COPY		#类似于ADD命令，将我们的文件拷贝到镜像中</span><br><span class="line">ENV			#构建的时候设置环境变量</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;CMD和ENTRYPOINT的区别&#x3D;&#x3D;</p>
<p><strong>CMD</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动的时候会列出列表</span></span><br><span class="line">[root@wpeng dockerfile]# cat dockerfile-test-cmd </span><br><span class="line">FROM  centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">构建镜像</span></span><br><span class="line">[root@wpeng dockerfile]# docker build -f dockerfile-test-cmd -t cmdtest .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行，可以看到运行结果直接列出目录，run的时候会执行<span class="built_in">ls</span> -a命令</span></span><br><span class="line">[root@wpeng dockerfile]# docker run cmdtest</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">lost+found</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">想追加一个命令-l    执行<span class="built_in">ls</span> -al命令</span></span><br><span class="line">[root@wpeng dockerfile]# docker run cmdtest -l</span><br><span class="line">docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmd的情况下  -l替换了CMD[<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]命令，但是-l不是命令，所以报错</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">想解决错误，只能[root@wpeng dockerfile]<span class="comment"># docker run cmdtest ls -al</span></span></span><br></pre></td></tr></table></figure>

<p><strong>ENTRYPOINT</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动的时候会出现列表</span></span><br><span class="line">[root@wpeng dockerfile]# cat dockerfile-cmd-entrypoint </span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">构建镜像</span></span><br><span class="line">[root@wpeng dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entrypoint-test .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">附加-l参数启动容器，我们的追加命令直接拼接在ENTRYPOINT命令的后面</span></span><br><span class="line">[root@wpeng dockerfile]# docker run entrypoint-test -l</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 15 02:59 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 15 02:59 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 May 15 02:59 .dockerenv</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 May 15 02:59 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 15 02:59 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------   2 root root 4096 Sep 15  2021 lost+found</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 media</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 opt</span><br><span class="line">dr-xr-xr-x 231 root root    0 May 15 02:59 proc</span><br><span class="line">dr-xr-x---   2 root root 4096 Sep 15  2021 root</span><br><span class="line">drwxr-xr-x  11 root root 4096 Sep 15  2021 run</span><br><span class="line">lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 srv</span><br><span class="line">dr-xr-xr-x  13 root root    0 May 15 02:59 sys</span><br><span class="line">drwxrwxrwt   7 root root 4096 Sep 15  2021 tmp</span><br><span class="line">drwxr-xr-x  12 root root 4096 Sep 15  2021 usr</span><br><span class="line">drwxr-xr-x  20 root root 4096 Sep 15  2021 var</span><br></pre></td></tr></table></figure>

<h3 id="7-4实战测试"><a href="#7-4实战测试" class="headerlink" title="7.4实战测试"></a>7.4实战测试</h3><p>DockerHub中百分99的镜像都是从这个基础镜像过来的  FROM scratch，然后配置需要的软件和配置来进行构建</p>
<p><img src="https://www.freeimg.cn/i/2024/05/14/66434f85cbc40.png" alt="https://www.freeimg.cn/i/2024/05/14/66434f85cbc40.png"></p>
<p><strong>创建一个自己的centos</strong></p>
<p>1.编写dockerfile的编写文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng home]# cd dockerfile </span><br><span class="line">[root@wpeng dockerfile]# ls</span><br><span class="line">[root@wpeng dockerfile]# vim wpengdockerfile</span><br><span class="line"></span><br><span class="line">[root@wpeng dockerfile]# cat wpengdockerfile </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER wpeng&lt;2119026961@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 8090</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;----end-----&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>2.通过这个文件构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng dockerfile]# docker build -f wpengdockerfile -t mycentos:0.1 .</span><br><span class="line">[+] Building 14.9s (9/9) FINISHED                                                                                          docker:default</span><br><span class="line"> =&gt; [internal] load build definition from wpengdockerfile                                                                            0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 473B                                                                                                 0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/centos:latest                                                                     0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                      0.0s</span><br><span class="line"> =&gt; [1/5] FROM docker.io/library/centos:latest                                                                                       0.0s</span><br><span class="line"> =&gt; CACHED [2/5] WORKDIR /usr/local                                                                                                  0.0s</span><br><span class="line"> =&gt; [3/5] RUN sed -i &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; /etc/yum.repos.d/CentOS-*.repo     &amp;&amp; sed -i &#x27;s|^#baseurl=http://mirror.centos  5.5s</span><br><span class="line"> =&gt; [4/5] RUN yum -y install vim                                                                                                     6.2s </span><br><span class="line"> =&gt; [5/5] RUN yum -y install net-tools                                                                                               2.1s </span><br><span class="line"> =&gt; exporting to image                                                                                                               1.1s </span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                              1.0s </span><br><span class="line"> =&gt; =&gt; writing image sha256:bb179add7bd4004d7112989dba95ddc1a361713854f6839a01d636acc36c060e                                         0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/mycentos:0.1 </span><br></pre></td></tr></table></figure>

<p>3.测试运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng dockerfile]# docker run -it mycentos:0.1</span><br><span class="line">[root@11b0db9ce40c local]# pwd </span><br><span class="line">/usr/local</span><br><span class="line">[root@11b0db9ce40c local]# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.10  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:0a  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 14  bytes 1181 (1.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@11b0db9ce40c local]# vim test</span><br><span class="line">[root@11b0db9ce40c local]# ls</span><br><span class="line">bin  etc  games  include  lib  lib64  libexec  sbin  share  src  test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">官方原生的</span></span><br><span class="line">pwd是根目录，我们这里配置了工作目录 /usr/local</span><br><span class="line">官方没有vim命令，我们配置的镜像会有vim命令</span><br></pre></td></tr></table></figure>

<p>我们可以列出本地镜像的变更历史</p>
<p>docker histtory 镜像名或者id</p>
<h3 id="7-5制作Tomcat镜像"><a href="#7-5制作Tomcat镜像" class="headerlink" title="7.5制作Tomcat镜像"></a>7.5制作Tomcat镜像</h3><p>1.准备镜像文件tomcat压缩包，jdk的压缩包！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng ~]# cd /home</span><br><span class="line">[root@wpeng home]# ls</span><br><span class="line">Mytest  ceshi  docker-test-volume  dockerfile  mysql  test.java  wpeng</span><br><span class="line">[root@wpeng home]# cd wpeng/</span><br><span class="line">[root@wpeng wpeng]# ls</span><br><span class="line">apache-tomcat-9.0.87  apache-tomcat-9.0.87.tar.gz  jdk-8u202-linux-x64.tar.gz  jdk1.8.0_202</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.编写dockerfile文件，官方命名：Dockerfile，build的时候会自动寻找这个文件，就不需要-f指定了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng wpeng]# vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM centos: 7</span><br><span class="line">MAINTAINER wpeng&lt;2119026961@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD jdk-8u202-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.87.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_11</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.87</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.87</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8091</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.87/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.87/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>

<p>3.构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng wpeng]# docker build -t diytomcat .</span><br><span class="line">[+] Building 0.0s (1/1) FINISHED                                                                                           docker:default</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 635B                                                                                                 0.0s</span><br><span class="line">Dockerfile:1</span><br><span class="line">--------------------</span><br><span class="line">   1 | &gt;&gt;&gt; FROM centos: 7</span><br><span class="line">   2 |     MAINTAINER wpeng&lt;2119026961@qq.com&gt;</span><br><span class="line">   3 |     </span><br><span class="line">--------------------</span><br><span class="line">ERROR: failed to solve: dockerfile parse error on line 1: FROM requires either one or three arguments</span><br><span class="line">[root@wpeng wpeng]# vim dockerfile</span><br><span class="line">[root@wpeng wpeng]# vim Dockerfile </span><br><span class="line">[root@wpeng wpeng]# docker build -t diytomcat .</span><br><span class="line">[+] Building 51.7s (10/10) FINISHED                                                                                        docker:default</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 634B                                                                                                 0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/centos:7                                                                          3.7s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                      0.0s</span><br><span class="line"> =&gt; [1/5] FROM docker.io/library/centos:7@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4                   22.1s</span><br><span class="line"> =&gt; =&gt; resolve docker.io/library/centos:7@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4                    0.0s</span><br><span class="line"> =&gt; =&gt; sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4 1.20kB / 1.20kB                                       0.0s</span><br><span class="line"> =&gt; =&gt; sha256:dead07b4d8ed7e29e98de0f4504d87e8880d4347859d839686a31da35a3b532f 529B / 529B                                           0.0s</span><br><span class="line"> =&gt; =&gt; sha256:eeb6ee3f44bd0b5103bb561b4c16bcb82328cfe5809ab675bb17ab3a16c517c9 2.75kB / 2.75kB                                       0.0s</span><br><span class="line"> =&gt; =&gt; sha256:2d473b07cdd5f0912cd6f1a703352c82b512407db6b05b43f2553732b55df3bc 76.10MB / 76.10MB                                    18.3s</span><br><span class="line"> =&gt; =&gt; extracting sha256:2d473b07cdd5f0912cd6f1a703352c82b512407db6b05b43f2553732b55df3bc                                            3.4s</span><br><span class="line"> =&gt; [internal] load build context                                                                                                    1.6s</span><br><span class="line"> =&gt; =&gt; transferring context: 205.84MB                                                                                                1.6s</span><br><span class="line"> =&gt; [2/5] ADD jdk-8u202-linux-x64.tar.gz /usr/local/                                                                                 4.4s</span><br><span class="line"> =&gt; [3/5] ADD apache-tomcat-9.0.87.tar.gz /usr/local/                                                                                0.4s</span><br><span class="line"> =&gt; [4/5] RUN yum -y install vim                                                                                                    17.7s</span><br><span class="line"> =&gt; [5/5] WORKDIR /usr/local                                                                                                         0.0s </span><br><span class="line"> =&gt; exporting to image                                                                                                               3.2s </span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                              3.2s </span><br><span class="line"> =&gt; =&gt; writing image sha256:70cec7e14015b6051ea93fc15d530151d092682565790deb41fb464e65c044cc                                         0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/diytomcat   </span><br></pre></td></tr></table></figure>

<h3 id="7-6发布自己的镜像"><a href="#7-6发布自己的镜像" class="headerlink" title="7.6发布自己的镜像"></a>7.6发布自己的镜像</h3><p><strong>发布镜像到dockerhub上</strong></p>
<p>1.登录到dockerhub上</p>
<p>2.在我们的服务器上提交自己的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng ~]# docker login --help</span><br><span class="line"></span><br><span class="line">Usage:  docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log in to a registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br></pre></td></tr></table></figure>

<p>3.登录完毕后就可以提交镜像了，就是一步docker push</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.项目创建完成后，返回控制台，列出所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2、将要发布的镜像修改标记，标记为自己账号下。此处我的项目名：yuki03233</span></span><br><span class="line">docker tag consul yuki03233/consul</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3、发布镜像</span></span><br><span class="line">docker push yuki03233/consul</span><br></pre></td></tr></table></figure>

<p><strong>发布镜像到阿里云服务器上</strong></p>
<p>1.登录阿里云，找到镜像服务</p>
<p>2.创建命名空键7</p>
<p>3.创建容器镜像</p>
<h2 id="8-Docker网络"><a href="#8-Docker网络" class="headerlink" title="8.Docker网络"></a>8.Docker网络</h2><h3 id="8-1-理解docker0"><a href="#8-1-理解docker0" class="headerlink" title="8.1 理解docker0"></a>8.1 理解docker0</h3><p>三个网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker 是如何处理容器网络访问的</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器的内部网络地址  ip addr</span></span><br><span class="line"></span><br><span class="line">docker inspect container-id  #审查容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux可以ping通docker容器内部</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<ol>
<li><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，        桥接模式，使用的技术是evth-pair技术</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们发现这个容器带来网卡，都是一对对的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">正是因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8-2-自定义网络"><a href="#8-2-自定义网络" class="headerlink" title="8.2 自定义网络"></a>8.2 自定义网络</h3><p>查看所有的docker网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p><strong>网络模式</strong></p>
<p>bridge：桥接 docker （默认，使用veth技术）</p>
<p>none：不配置网络</p>
<p>host：主机模式，和宿主机共享网络</p>
<p>container：容器网络联通（用的少，局限性很大</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建网络</span></span><br><span class="line">[root@wpeng /]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">b23f86d94b2f50d050aed77f82d62ad94d537f86c4f0399606b66ab8c2807868</span><br><span class="line">[root@wpeng /]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c539b81d49ac   bridge    bridge    local</span><br><span class="line">06e90eab0aaf   host      host      local</span><br><span class="line">b23f86d94b2f   mynet     bridge    local</span><br><span class="line">6cd224f00fba   none      null      local</span><br><span class="line">05af1142be47   zk        bridge    local</span><br></pre></td></tr></table></figure>

<p>检查自己的网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@wpeng /]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;b23f86d94b2f50d050aed77f82d62ad94d537f86c4f0399606b66ab8c2807868&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2024-06-18T23:26:12.7419496+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-3-网络联通"><a href="#8-3-网络联通" class="headerlink" title="8.3 网络联通"></a>8.3 网络联通</h3>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>DeployTools</tag>
        <tag>DevelopTools</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2024/06/30/MysqlBase/</url>
    <content><![CDATA[<p>1.DDL</p>
<p>DDL-数据库操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">显示所有的数据库 <span class="keyword">show</span> databases</span><br><span class="line">创建数据库 <span class="keyword">create</span> database 数据库名</span><br><span class="line">使用数据库 use 数据库名</span><br><span class="line">查询当前处于哪个数据库 <span class="keyword">select</span>   database()</span><br><span class="line">删除数据库 <span class="keyword">drop</span> database 数据库名	</span><br></pre></td></tr></table></figure>


<p>DDL-表操作-查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询当前数据库所有表	<span class="keyword">show</span> tables</span><br><span class="line">查询表结构	<span class="keyword">desc</span> 表名</span><br><span class="line">查询指定表的建表语句	<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>DDL-表操作-创建		</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">			字段<span class="number">1</span> 字段<span class="number">1</span>类型[comment 字段<span class="number">1</span>注释],</span><br><span class="line">			字段<span class="number">2</span> 字段<span class="number">2</span>类型[comment 字段<span class="number">2</span>注释],</span><br><span class="line">			.......</span><br><span class="line">			字段N 字段N类型[comment 字段N注释]        该字段后面没有逗号</span><br><span class="line">		      )[comment 表注释];</span><br></pre></td></tr></table></figure>

<p>DDL-表操作-修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">添加字段	 <span class="keyword">alter</span>  <span class="keyword">table</span> 表名 <span class="keyword">add</span>  字段名 类型(长度)</span><br><span class="line">修改数据类型 <span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 新数据类型()</span><br><span class="line">修改字段名和字段类型 <span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧字段名 新字段名 类型(长度)</span><br><span class="line">删除字段 <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名</span><br><span class="line">修改表名 <span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新表名</span><br></pre></td></tr></table></figure>

<p>DDL-表操作-删除</p>
<pre><code>        删除表 drop table[if exists] 表名
        删除指定表，并重新创建该表 truncate table 表名
</code></pre>
<p>2.DML</p>
<p>DML-添加数据 </p>
<pre><code>        1.给指定数段添加数据 insert   into 表名(字段名1,字段名2,...)values(值1，值2,...)
        2.给全部字段插入数据  insert into 表名  values (值1，值2，...)
        3.批量添加数据  	insert into 表名(字段1,字段2，...) values(值1,值2，...)
                        insert into 表名  values (值1，值2，...)
        //注意字符串和日期型数据应该包含在引号中
</code></pre>
<p>DML-修改数据</p>
<pre><code>        update 表名  set 字段名1=值1，字段名2=值2... where 条件   条件可以有也可以没有，如果没有则会修改整张表的数据
</code></pre>
<p>DML-删除数据</p>
<pre><code>        delete from 表名 where 条件  
        //delete语句不能删除某一个字段，可以用update，是字段的值=null
</code></pre>
<p>3.DQL</p>
<p>DQL-基本查询</p>
<pre><code>        1.查询多个字段  select 字段1，字段2，...from 表名、
                       select * from 表名
        2.设置别名 select 字段1[as 别名],字段2[as 别名]...from 表名
        3.去除重复记录 select  distinct 字段列表 from 表名
</code></pre>
<p>DQL-条件查询</p>
<pre><code>        1.语法  select 字段列表 from 表名  where 条件列表
        2.条件 比较运算符  大于小于等    like占位符(模糊匹配 _匹配单个字符,%匹配多个字符0) isNULL是NULl  between and 在某个范围之间 
               逻辑运算符  and或者&amp;&amp; or或者||  not或者！ 
</code></pre>
<p>DQL-聚合函数</p>
<pre><code>        1.常见聚合函数
        count 统计数量
        max 最大值
        min 最小值
        avg 平均值
        sum 求和
        2.语法 select 聚合函数(字段列表) from 表名   where 条件
        注意 null值不参与所有聚合函数运算   字段列表就是表名.字段名或者字段名
</code></pre>
<p>DQL-分组查询</p>
<pre><code>        select字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];
        
        注意:分组之后，查询的字段为聚合函数和分组字段,查询其他字段无任何意义 
        -- where和having区别:
        
        执行时机不一样: where 是分组之前进行限定，不满足where条件,则不参与分组，而having是分组之后对结果进行过滤。
        可判断的条件不一 样: where 不能对聚合函数进行判断，having 可以。
        -- 执行顺序: where &gt;聚合函数&gt; having
        
        -- 1.查询男同学和女同学各自的数学平均分
        select avg(math) from stu group by sex ;
         
        -- 注意:分组之后，查询的字段为聚合函数和分组字段,查询其他字段无任何意义 
        select sex,avg(math) from stu group by sex ;
         
        -- 2.查询男同学和女同学各自的数学平均分，以及各自人数
        select sex,avg(math),count(*) from stu group by sex ;
         
        -- 3.查询男同学和女同学各自的数学平均分，以及各自人数，要求:分数低于70分的不参与分组
        select sex,avg(math),count(*) from stu where math &gt;70 group by sex ;
         
        -- 4.查询男同学和女同学各自的数学平均分，以及各自人数，要求:分数低于70分的不参与分组，分组之后人数大于2
        select sex,avg(math),count(*) from stu where math &gt;70 group by sex having count(*) &gt; 2 ;
</code></pre>
<p>DQL—排序查询</p>
<pre><code>        SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] ..
    
            排序方式:
            
            ASC:升序排列(默认值)
            DESC: 降序排列
            注意:如果有多个排序条件，当前边的条件值一-样时, 才会根据第二条件进行排序。
</code></pre>
<p>​				<br>​				原本的数据（是按照id升序排列的）<br>​				<br>​				1.查询学生信息，按照年龄升序排列<br>​				<br>                select * from stu order by age asc ;&#x2F;&#x2F;asc可以不写，默认是升序排序</p>
<pre><code>            2.查询学生信息，按照数学成绩降序排列 
            
            select * from stu order by math desc ;
            
             3.查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列
            
            select * from stu order by math desc, english asc ;
</code></pre>
<p>DQl-分页查询</p>
<pre><code>            分页查询
            
            应用场景：当页面上的数据，一页显示不全，则需要分页显示
            
            分页查询的sql命令请求数据库服务器 —&gt; 服务器响应查询到的多条数据 —&gt; 前台页面
            
            语法：
            select 字段列表 from 表名 limit 起始索引，查询记录数
            起始索引从0开始 起始索引=(查询页码-1)*每页显示记录数
            select 查询列表
            from 表1 别名
            join 表2 别名
            on 连接条件
            where 筛选条件
            group by 分组
            having 分组后筛选
            order by 排序列表
            limit 起始条目索引，显示的条目数
</code></pre>
<p>​				<br>​				执行顺序：<br>​				<br>​				1&gt; from 子句<br>​				2&gt; join 子句<br>​				3&gt; on 子句<br>​				4&gt; where 子句<br>​				5&gt; group by 子句<br>​				6&gt; having 子句<br>​				7&gt; select 子句<br>​				8&gt; order by 子句<br>​				9&gt; limit 子句<br>​				<br>                特点：</p>
<pre><code>            起始条目索引如果不写，默认为0
            #案例1：查询员工信息表的前5条
            SELECT * FROM employees LIMIT 0,5;
            #完全等价于
            SELECT * FROM employees LIMIT 5;
            
            limit后面支持两个参数
            参数一：显示的起始条目索引
            参数二：条目数
            #案例2：查询有奖金的，且工资较高的第11名到第20名
            SELECT *
            FROM employees
            WHERE commission_pct IS NOT NULL
            ORDER BY salary DESC
            LIMIT 10,10;
            注意：分页查询中的索引用0开始
            
            公式：
            要显示的页数是page，每页显示的条目数为size
            select *
            from employees
            limit (page-1)*size,size;
</code></pre>
<p>DQL-综合练习	</p>
<pre><code>            假如有一个person表，属性有age，gender，name，id，address等
            1.查询年龄为20，21，22，23岁的女性员工信息
                select * from person  where gender=&#39;女&#39; and age in(20,21,22,23)
            2.查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工
                select * from person where sex=男 and(age between 20 and 40)and name like &#39;___&#39;
            3.统计员工表中，年龄小于60，男性员工和女性员工的人数
                select  gender,count(*) from person where age&lt;60 group by gender
            4.查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结构按年龄进行升序排序，如果年龄相同则按照入职时间降序排序
                select name,age from person  where age&lt;=35 order by age asc,entrytime desc
            5.查询性别为男，且年龄在20-40（含)以内的前五个员工信息，对查询结果按年龄升序排序，年龄相同按照入职时间降序排序
                select * where age=&#39;男&#39;and age between 20 and 40 order by age asc,entrytime desc limit 5
</code></pre>
<p>DQL-执行顺序</p>
<pre><code>            一个完整的DQL语句的语法格式：
    
                select ... from ... where ... group by ... having ... order by ..		
                执行顺序：
                select ...  		5	
                from ...   			1
                where ... 			2
                group by ... 		3
                having ... 			4
                order by ..			6
            
                1从哪张表中查，from
                2筛选出要求的信息 where
                3再进行分组 group by
                4分组后再筛选出有符合要求的信息 having
                5然后根据字段查出来 select
                6最后排序输出
</code></pre>
<p>4.DCl</p>
<p>DCL-用户管理</p>
<pre><code>        DCL:管理用户，授权
        1.管理用户
        ①添加用户
            语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
            例子：CREATE USER &#39;xiaozhi&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;
                
        ②删除用户
            语法：drop user &#39;用户名&#39;@&#39;主机名&#39;;
            例子：DROP USER &#39;xiaozhi&#39;@&#39;%&#39;;
        
        ③修改用户密码
            第一种方式：
                语法：UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;
                例子：UPDATE USER SET PASSWORD = PASSWORD(&#39;123456&#39;) WHERE USER = &#39;xiaozhi&#39;;
            第二种方式：
                语法：SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);
                例子：SET PASSWORD FOR &#39;xiaozhi&#39;@&#39;%&#39; = PASSWORD(&#39;abc&#39;);
    
             mysql数据库中忘记了root用户的密码？
                    1. cmd -- &gt; net stop mysql 停止mysql服务
                            需要管理员运行该cmd
                    2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                    3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                    4. use mysql;
                    5.flush privilleges;
                        说明：如果没有进行这个步骤进行下一步就会报错。
                    6. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
                    7. 关闭两个窗口
                    8. 打开任务管理器，手动结束mysqld.exe 的进程
                    9. 启动mysql服务
                    10. 使用新密码登录。
    
            ④查询用户
            ①使用user数据库中
            ②查询
            语法：select * from user;
    
        2.授权
        ①查询权限：
                SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;
                
        ②授予权限：
                语法：grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;
                例子：给xiaozhi用户授予所有权限，在任意数据库任意表上
                        GRANT ALL ON *.* TO &#39;xiaozhi&#39;@&#39;%&#39;;
                通配符ALL和*：ALL表示全部权限
                                *表示全部
    
        ③撤销权限：
                语法：revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;
                例子：REVOKE ALL ON *.* FROM &#39;xiaozhi&#39;@&#39;%&#39;;
    
            列子
                1.创建用户itcast，只能够在当前主机localhost访问，密码123456
                    create user &#39;itcast&#39;@&#39;localhost&#39;  identified by &#39;123456&#39;
                2.创建heima，可以在任意主机访问该数据库，密码123456
                    create &#39;heima&#39;@* identified by &#39;123456&#39;
                3.修改用户heima的访问密码为1234
                    update user set password=password(&#39;1234&#39;) where user=&#39;heima&#39;
                4.删除itcast@localhost用户
                    drop uesr &#39;itcast&#39;@&#39;localhost&#39;
</code></pre>
<p>DCL-控制权限</p>
<pre><code>        查询权限
            SHOW GREANTS FOR ‘用户名’@‘主机名’;
    
        授予权限
            GRANT 权限列表 ON 数据库名.表名 TO ‘用户名’@‘主机名’;
    
        撤销权限
            REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名’@‘主机名’;
</code></pre>
<p>函数</p>
<p>1.字符串函数</p>
<pre><code>常用字符串函数 
    1.字符串拼接 
        concat(s1,s2,s3,...)
    2.去除字符串头部和尾部的空格
        trim(str)
    3.返回从字符串str从start位置起的len个长度的字符串
        substring(str,start,len)
    4.左右填充  用字符串pad对字符串str的左右进行填充，达到n个字符串长度
        lpad(str,n,pad)
        rpad(str,n,pad)

由于业务需求变更，企业员工编号统一为五位数，目前不足五位数的向左补0，如1号员工的编号为00001
    update person set worknumber=lpad(worknumber,5,&#39;0&#39;)
        //person是表名，worknumber是字段名，l是left
</code></pre>
<p>2.数值函数</p>
<pre><code>常用数值函数
    1.cell(x) 向上取整
    2.floor(x) 向下取整
    3.mod(x 返回x/y的模
</code></pre>
<p>3.流程函数</p>
<pre><code>统计学院的成绩，展示规则如下
学员的属性有name id math chinese english  表的名字 是score
    &gt;=85优秀  &gt;=60及格  &lt;60 不及格
    select 
        id,
        name,
        (case when math &gt;85 then &#39;优秀&#39; when math &gt;60 then &#39;及格&#39; when math  &lt;60 then &#39;不及格&#39; )math,
        (case when english &gt;85 then &#39;优秀&#39; when english&gt;60 then &#39;及格&#39; when english &lt;60 then &#39;不及格&#39; )english,
        (case when chinese &gt;85 then &#39;优秀&#39; when chinese &gt;60 then &#39;及格&#39; when chinese &lt;60 then &#39;不及格&#39; )chinese
    from score;
</code></pre>
<p>约束</p>
<pre><code>1.约束的分类
    主键约束(primary key) PK
    自增长约束(auto_increment)
    非空约束(not null)
    唯一性约束(unique)
    默认约束(default)
    零填充约束(zerofill)
    外键约束(foreign key) FK
    检查约束(check(条件)) 
        实例
            create  table  user(
                    id int primary key auto_increment comment &#39;主键约束&#39;,
                    name varchar(10) not null  unique  comment &#39;非空约束和唯一性约束&#39;,
                    age int check ( age&gt;0&amp;&amp;age&lt;120 ) comment &#39;检查约束&#39;,
                    status varchar(1) default &#39;1&#39; comment&#39;默认约束&#39;,
                    gender char(1)
             )comment &#39;用户表&#39;;


2.外键约束
    作用:外键可以让两张表的数据之间建立连接，从而保证数据的一致性和完整性
    添加外键
        1.创建表的同时添加外键
                create table score(
                score int(3),
                st_id int(16),
                cs_id int(16),
                primary key(st_id,cs_id),
                FOREIGN KEY (st_id) REFERENCES student(id),
                FOREIGN KEY (cs_id) REFERENCES classes(id)
                );
                            
        2. 已经创建表了怎么办：在表的定义外进行添加
                alter table 表名 add constraint FK_ID foreign key(你的外键字段名) REFERENCES 外表表名(对应的表的主键字段名);
        3.删除外键
            alter table 表名 drop foreign key 外键名称

        4.外键删除和更新行为				
        NO ACTION	在父表中删除/更新记录时，首先检查记录中是否有外键，有则不允许删除/更新
        RESTRICT	当在父表中删除/更新记录时，首先检查记录中是否有外键,有则不允许删除/更新
        CASCADE	当在父表中删除/更新记录时，首先检查该记录是否有对应的外键，如果有，则也删除/更新外键在子表中的记录
        set NULL	当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中外键值为null
        set default	父表变更时，子表将外键列设置成一个默认的值(Innodb不支持)
</code></pre>
<p>多表查询</p>
<pre><code>    连接查询
        1.内连接  inner join：只返回两个表中连接字段相等的行。
            演示:查询每一个员工的姓名以及相关部门的名称 表结构 emp,dept 连接条件 empt.dept_id=dept.id
                select emp.name dept.name from emp,dept where  empt.dept_id=dept.id 这是隐式内连接
                select e.name d.name from emp e,dept d where  e.dept_id=dept.id  给emp和dept起了别名e和p
                select e.name d.name from emp e ineer join on e.dept_id=dept.id  给emp和dept起了别名e和p，但是这是显式内连接，且inner关键字可以删除


        2.外连接
                left join（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
                right join（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
                full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。
</code></pre>
]]></content>
      <categories>
        <category>RelationalDatabases</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot</title>
    <url>/2024/07/01/SpringBoot/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1-创建springboot项目"><a href="#1-创建springboot项目" class="headerlink" title="1.创建springboot项目"></a>1.创建springboot项目</h2><p>创建一个springinitializr项目，选择对应的依赖，完成项目的创建</p>
<p><strong>项目的目录结构中会有一个程序的主入口以及一个空的配置文件</strong><br>    以添加了spring-web依赖的springboot项目为例子，pom文件配置如下</p>
<p>&#x3D;&#x3D;如果jdk版本为8，则需要修改spring-boot-starter-parent的版本低于3开头的版本，因为3以上版本需要jdk最低的版本为17&#x3D;&#x3D;</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringBootTest1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringBootTest1<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>22<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  springboot项目中的依赖都是以spring-boot-starter开头的     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web依赖：tomcat，dispatcherServlet，xml，...        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  单元测试依赖      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  打jar包的插件      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;在application.properties配置文件中可以修改端口号等等&#x3D;&#x3D;</p>
<h2 id="2-SpringBoot自动装配原理"><a href="#2-SpringBoot自动装配原理" class="headerlink" title="2.SpringBoot自动装配原理"></a>2.SpringBoot自动装配原理</h2><p>自动配置：</p>
<p><strong>pom.xml</strong></p>
<ul>
<li>spring-boot-dependencies：核心依赖在父工程中</li>
<li>我们在写入或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库</li>
</ul>
<p><strong>启动器</strong></p>
<ul>
<li><pre><code class="xml">       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 启动器：说白了就是SpringBoot的启动场景</span><br><span class="line"></span><br><span class="line">- 比如说spring-boot-starter-web，他就会帮我们自动导入web环境的所有依赖</span><br><span class="line"></span><br><span class="line">- springboot会将所有的功能场景，都变成一个个启动器</span><br><span class="line"></span><br><span class="line">- 我们要使用什么功能，只需要找到对应的启动器就可以了</span><br><span class="line"></span><br><span class="line">**主程序**</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //springboot本身就是spring的一个组件</span><br><span class="line">  //程序的主入口，不能删不能改</span><br><span class="line">  @SpringBootApplication//标注这个类是一个springboot的应用</span><br><span class="line">  public class SpringBootTest1Application &#123;</span><br><span class="line">      //将springboot应用启动</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          SpringApplication.run(SpringBootTest1Application.class, args);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>springApplication类主要做的四大事件</p>
<ol>
<li>推断应用的类型是普通项目还是web项目</li>
<li>查找并加载所有可用初始化器，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，设置到listeners属性中</li>
<li>推断并设置main方法的定义类，找到运行的主类</li>
</ol>
</li>
</ul>
<p>结论：springboot所有自动配置都是在启动的时候，扫描并且加载：<strong>spring.factories</strong>所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们的自动装配就会生效，然后配置成功</p>
<ol>
<li>springboot在启动的时候，从类的路径下 <strong>&#x2F;META-INF&#x2F;spring.factories</strong>获取指定值</li>
<li>将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置</li>
<li>以前我们需要手动配置的东西，springboot帮我们做了</li>
<li>整合javaEE，解决方案和自动装配的东西都在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包下</li>
<li>它会把所有需要导入的组件，以类名的形式返回，这些组件就会被添加到容器</li>
<li>容器中也会存在非常多的xxxAutoConfiguration的文件(@Bean)，就是这些类给容器中导入了这个场景所需要的所有组件，并且自动配置</li>
<li>有了自动配置类，免去了我们手动编写配置文件的工作</li>
</ol>
<h2 id="3-Springboot配置"><a href="#3-Springboot配置" class="headerlink" title="3.Springboot配置"></a>3.Springboot配置</h2><p>我们一般不用后缀为properties的配置文件，而用后缀为yml的配置文件</p>
<p>yaml可以直接给实体类赋值</p>
<p>下面是yaml表达式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">qingjiang</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">happy:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/11/02</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">girl</span></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">旺财</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>对应的person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean happy;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yaml配置文件对person的属性进行批量赋值</p>
<h2 id="4-SpringBoot-Web开发"><a href="#4-SpringBoot-Web开发" class="headerlink" title="4.SpringBoot Web开发"></a>4.SpringBoot Web开发</h2><p>jar：webapp！</p>
<p>自动装配</p>
<p>springboot到底帮我们装配了什么，能不能进行修改，能修改哪些东西，能不能进行拓展</p>
<ol>
<li>xxxAutoConfigure：   向容器中自动装配组件</li>
<li>xxxProperties ：自动装配类，装配配置文件中自定义的一些内容</li>
</ol>
<p>web开发解决的问题：</p>
<ul>
<li>导入静态资源问题……..</li>
<li>首页</li>
<li>jsp，模板引擎Thymeleaf</li>
<li>装配拓展springmvc</li>
<li>增删改查</li>
<li>拦截器</li>
<li>国际化</li>
</ul>
<p>静态资源总结：</p>
<p>1.在springboot，我们可以使用以下方式处理静态资源</p>
<ul>
<li>webjars   localhost:8080&#x2F;webjars&#x2F;</li>
<li>public ,static,&#x2F;**,resources   localhost:8080&#x2F;</li>
</ul>
<p>2.优先级：resources&gt;static（默认）&gt;public</p>
<h2 id="5-模板引擎"><a href="#5-模板引擎" class="headerlink" title="5.模板引擎"></a>5.模板引擎</h2><p>导入对应的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将html页面放在templates目录下即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;.html&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-员工管理系统"><a href="#6-员工管理系统" class="headerlink" title="6.员工管理系统"></a>6.员工管理系统</h2><h3 id="6-1首页"><a href="#6-1首页" class="headerlink" title="6.1首页"></a>6.1首页</h3><p>根目录下面的东西最好在config类里面配置</p>
<p>在html头部添加  xmlns:th&#x3D;”<a href="http://www.thymeleaf.org"约束/">http://www.thymeleaf.org&quot;约束</a></p>
<p>在属性面前添加th</p>
<h3 id="6-2登录"><a href="#6-2登录" class="headerlink" title="6.2登录"></a>6.2登录</h3><p>给index.html页面绑定username和password属性</p>
<h2 id="7-SpringBoot整合JDBC"><a href="#7-SpringBoot整合JDBC" class="headerlink" title="7.SpringBoot整合JDBC"></a>7.SpringBoot整合JDBC</h2><h3 id="7-1整合JDBC"><a href="#7-1整合JDBC" class="headerlink" title="7.1整合JDBC"></a>7.1整合JDBC</h3><p><strong>springboot默认的数据源是hikari</strong></p>
<p>连接数据库的application.yaml配置文件如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">20050116</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat,wall,log4j</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-2SpringBoot整合Druid"><a href="#7-2SpringBoot整合Druid" class="headerlink" title="7.2SpringBoot整合Druid"></a>7.2SpringBoot整合Druid</h3><p>更换springboot的数据源：**在yaml文件中配置  type： 数据源的名称</p>
<p>Druid自带有log4j日志功能，需要导入log4j-core的依赖</p>
<p><strong>Druid绑定yaml文件：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidConfig</span> &#123;</span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对如上代码的解释</p>
<p>这段代码是一个典型的Spring Boot中使用<code>@Configuration</code>注解配置数据源的示例。下面是每一行代码的解释：</p>
<ol>
<li><p><code>@Configuration</code>: 这是一个注解，用于标识这个类是一个配置类，它告诉Spring容器这个类包含了Bean的配置信息。</p>
</li>
<li><p><code>public class DruidConfig &#123;</code>: 定义了一个名为<code>DruidConfig</code>的Java类，这个类用于配置Druid数据源。</p>
</li>
<li><p><code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</code>: 这是一个Spring Boot提供的注解，它能够从<code>application.properties</code>或<code>application.yml</code>文件中读取以<code>spring.datasource</code>开头的属性，并将它们绑定到对应的字段或属性上。</p>
</li>
<li><p><code>@Bean</code>: 这是一个方法级别的注解，用于告诉Spring容器，这个方法将会返回一个Bean，并且将其加入到容器中。在这个示例中，<code>dataSource()</code>方法将返回一个<code>DataSource</code>类型的Bean。</p>
</li>
<li><p><code>public DataSource dataSource()&#123;</code>: 这是一个公共方法，返回类型为<code>DataSource</code>，方法名为<code>dataSource()</code>，它是用来创建并配置数据源Bean的。</p>
</li>
<li><p><code>return new DruidDataSource();</code>: 在<code>dataSource()</code>方法中，创建了一个新的<code>DruidDataSource</code>对象，并将其作为数据源Bean返回。</p>
</li>
</ol>
<p>通过以上代码，Spring容器会读取<code>application.properties</code>或<code>application.yml</code>中以<code>spring.datasource</code>开头的属性，然后将这些属性值绑定到<code>DruidDataSource</code>对象中，最后将这个数据源Bean加入到Spring容器中供其他组件使用。</p>
<p><strong>Druid监控功能</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后台监控 ：web.xml,ServletRegistrationBean</span></span><br><span class="line"><span class="comment">//因为springboot内置了servlet容器，所以没有web.xml  替代方法：ServletRegistraBean  自己注入</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">StatViewServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">StatViewServlet</span>(), <span class="string">&quot;/druid/*&quot;</span>);<span class="comment">//druid是访问的url</span></span><br><span class="line">    <span class="comment">//后台需要登录，配置账号密码</span></span><br><span class="line">    HashMap&lt;String,String&gt; initParameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//增加配置</span></span><br><span class="line">    initParameters.put(<span class="string">&quot;loginUsername&quot;</span>,<span class="string">&quot;admin&quot;</span>); <span class="comment">//登录key是固定的，即loginUsername和loginPassword这两个键是不可改变的</span></span><br><span class="line">    initParameters.put(<span class="string">&quot;loginPassword&quot;</span>,<span class="string">&quot;20050116&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许谁可以访问</span></span><br><span class="line">   <span class="comment">// initParameters.put(&quot;allow&quot;,&quot;&quot;);如果allow后面的参数为空，则所有人都可以访问</span></span><br><span class="line">    initParameters.put(<span class="string">&quot;allow&quot;</span>,<span class="string">&quot;localhost&quot;</span>);<span class="comment">//一般是写具体的人，在这里是本机可以访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁止谁可以访问</span></span><br><span class="line">    <span class="comment">//initParameters.put(&quot;kuangshen&quot;,&quot;192.168.11.123&quot;);//配置完成后，禁止该ip进行访问</span></span><br><span class="line"></span><br><span class="line">    bean.setInitParameters(initParameters);<span class="comment">//设置初始化参数</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Druid过滤器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean <span class="title function_">webStatFilter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FilterRegistrationBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">    bean.setFilter(<span class="keyword">new</span> <span class="title class_">WebStatFilter</span>());</span><br><span class="line">    <span class="comment">//可以过滤哪些请求</span></span><br><span class="line">    HashMap&lt;String,String &gt; initParameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//这些东西不进行统计</span></span><br><span class="line">    initParameters.put(<span class="string">&quot;exclusion&quot;</span>,<span class="string">&quot;*.js,*.css,/druid/*&quot;</span>);</span><br><span class="line">    bean.setInitParameters(initParameters);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-SpringBoot整合Mybatis"><a href="#8-SpringBoot整合Mybatis" class="headerlink" title="8.SpringBoot整合Mybatis"></a>8.SpringBoot整合Mybatis</h2><p>整合包,导入mybatis-spring-boot-starter依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在application文件中配置mybatis：即&#x3D;&#x3D;整合mybatis&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis.type-aliases-<span class="keyword">package</span>=<span class="string">&quot;对应pojo包的位置&quot;</span></span><br><span class="line">mybatis.mapper-locations=classpath:<span class="string">&quot;mapper接口对用放xml文件的包的位置&quot;</span><span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure>

<p>写sql语句也可以使用注解开发，在对应方法上加上select注解，但是在复杂的关系表中不建议使用注解开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from users&quot;)</span></span><br><span class="line">List&lt;Users&gt; <span class="title function_">AllUser</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>SQL片段的作用和使用</strong>：</p>
<ul>
<li>作用：<br>  将重复的sql语句抽出来放到sql标签中，然后通过<code>&lt;include refid=”” /&gt;</code>来引入</li>
</ul>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sq1</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span>id,user_name,password,name,age,sex,birthday,created,updated<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>= <span class="string">&quot;queryUserByID&quot;</span> <span class="attr">parameterType</span>= <span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>= <span class="string">&quot;userResul tMap&quot;</span>&gt;</span></span><br><span class="line">	SELECT <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>/&gt;</span> FROM tb_ user WHERE id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用：</p>
<ul>
<li><p>在一个mapper.xml 中使用<code>&lt;sql id=(id就是一个标识)&gt;</code> 去定义sql片段，然后在需要的位置使用<code>&lt;include&gt;</code> 引入</p>
<p>注意：这里include里面的refid属性填写的内容是定义sql片段的id</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义sql片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>= <span class="string">&quot;userColumn &quot;</span>&gt;</span></span><br><span class="line">	id, user_ name,password, name , age, sex, birthday , created , updated</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--书写CURD操作 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id是方法的名字</span></span><br><span class="line"><span class="comment">resultType :结果集映射类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>= <span class="string">&quot;queryAllUser&quot;</span> <span class="attr">resultType</span>= <span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>= <span class="string">&quot;userColumn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from tb_ user</span><br><span class="line">&lt;/ select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有的公用的SQL片段集中定义到一个Mapper.xml文件中，其他Mapper.xml文件如需引入mybatis-config.xml，通过命名空间.id即可</p>
</li>
</ul>
<p>&#x3D;&#x3D;url请求都是get请求&#x3D;&#x3D;</p>
</li>
</ul>
<p><strong>@Mapper</strong></p>
<p><code>@Mapper</code>注解通常用于基于 MyBatis 框架的 Java 项目中。它的作用是将一个 Java 接口标记为 MyBatis 的映射器接口，用于定义 SQL 查询、更新、删除等数据库操作的方法。MyBatis 框架会根据这些接口生成对应的实现类，从而实现数据访问操作。</p>
<p><strong>@Repository</strong></p>
<p><code>@Repository</code> 注解通常用于 Spring 框架中的 Java 项目中。它的作用是将一个 Java 类标记为数据访问组件，通常用于与数据库交互的 DAO 类。<code>@Repository</code> 注解通常与其他 Spring 组件，如 <code>@Service</code> 或 <code>@Controller</code> 配合使用，以实现数据访问、业务逻辑处理和控制层的分离</p>
<h2 id="9-MVC架构再理解"><a href="#9-MVC架构再理解" class="headerlink" title="9.MVC架构再理解"></a>9.MVC架构再理解</h2><ol>
<li>对应数据库编写对应的实体类</li>
<li>dao层即数据对象访问层，跟mapper层差不多，在该层主要由接口构成，这些接口与数据库进行交互，定义一系列方法，每个方法对应一个对数据库的操作</li>
<li>service层即服务层，编写一个service接口和该service接口的实现类，在service接口写出相应方法，在实现类中继承接口，自动注入对应的Mapper接口，重写service接口里面的方法，调用mapper接口里面的方法并返回</li>
<li>controller层即控制层，在controller层自动注入service层接口，定义方法，在方法里面调用接口的方法，<strong>在Controller层通过接口类型注入Service时，Spring框架会自动找到该接口的某个实现类（前提是已经配置或扫描到了这个实现类，并且实现了接口中声明的所有方法）。在实际执行时，调用接口方法时，实际上是调用了该接口对应实现类中重写的方法。</strong></li>
</ol>
<h2 id="10-SpringSecurity"><a href="#10-SpringSecurity" class="headerlink" title="10.SpringSecurity"></a>10.SpringSecurity</h2><p>在web开发中，安全是第一位的，可以使用过滤器和拦截器进行保障安全(但是需要大量的原生代码,冗余),也可以使用框架保护安全</p>
<p>常见的安全框架：SpringSecurity,shiro</p>
<p>功能：认证，授权</p>
<p>权限的分类</p>
<ul>
<li>功能权限</li>
<li>访问权限</li>
<li>菜单权限</li>
</ul>
<p>AOP：横切 - 配置类  </p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Secutiry策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>EnableWebSecurity:开启WebSecurity模式</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>Springboot</tag>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2024/06/30/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><strong>Linux一切皆文件：文件就读,写  （权限）</strong></p>
<p>学习方式</p>
<ol>
<li>认识linux</li>
<li>基本的命令 （重点：Git讲了一些基本的命令(文件操作，目录管理，文件属性，Vim编辑器,账号管理，磁盘管理,..))</li>
<li>软件的安装和部署(java,tomcat,docker)</li>
</ol>
<span id="more"></span>



<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h2><p>云服务器就是一个远程电脑，服务器一般不会关机</p>
<p><img src="https://www.freeimg.cn/i/2024/05/05/663724ddd6665.png" alt="https://www.freeimg.cn/i/2024/05/05/663724ddd6665.png"></p>
<p>登录成功后，这里就是linux操作系统了！以后的操作都在这里操作，项目也在这里发布</p>
<p>ctrl＋鼠标滚轮：放大和缩小字体</p>
<p>xtfp用来上传文件</p>
<p><img src="https://www.freeimg.cn/i/2024/05/05/663767a27188d.png"></p>
<p>如果将本地文件，jar包，安装包等等，放到Linux只需要将左边的文件拖到右边就可以了</p>
<p>使用Tomcat需要安装java环境</p>
<p>xshell命令   ls-ll   竖列列出</p>
<p>​	</p>
<h2 id="2-走进Linux系统"><a href="#2-走进Linux系统" class="headerlink" title="2.走进Linux系统"></a>2.走进Linux系统</h2><blockquote>
<p>开机登录</p>
</blockquote>
<p>开机会启动许多程序，他们在Windows叫做服务(service)，在Linux就叫做守护进程（daemon）</p>
<p><strong>linux里面如果没有输出错误，即代表成功</strong></p>
<p>一般来说，用户的登陆方式有三种：</p>
<ul>
<li>命令行登录</li>
<li>ssh登录</li>
<li>图形界面登录</li>
</ul>
<p>最高权限账户为root，可以操作一切</p>
<blockquote>
<p>系统目录结构</p>
</blockquote>
<p><strong>1.一切皆文件</strong></p>
<p><strong>2.根目录&#x2F;，所有的文件都挂载在这个节点下</strong></p>
<p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><strong>&#x2F;bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>&#x2F;boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>&#x2F;dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>&#x2F;home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。&#x3D;&#x3D;</li>
<li><strong>&#x2F;lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li>
<li><strong>&#x2F;lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><strong>&#x2F;media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>&#x2F;mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。&#x3D;&#x3D;</li>
<li><strong>&#x2F;proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。&#x3D;&#x3D;</li>
<li><strong>&#x2F;sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>&#x2F;srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>&#x2F;sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;tmp</strong>：这个目录是用来存放一些临时文件的。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>&#x2F;usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。&#x3D;&#x3D;</li>
<li><strong>&#x2F;usr&#x2F;bin：</strong> 系统用户使用的应用程序。</li>
<li><strong>&#x2F;usr&#x2F;sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>&#x2F;usr&#x2F;src：</strong> 内核源代码默认的放置目录。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。&#x3D;&#x3D;</li>
<li><strong>&#x2F;run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
<li>&#x3D;&#x3D;&#x2F;www：存放服务器网站相关的资源，环境，网站的项目&#x3D;&#x3D;</li>
</ul>
<h2 id="3-常用的基本命令"><a href="#3-常用的基本命令" class="headerlink" title="3.常用的基本命令"></a>3.常用的基本命令</h2><p>在命令行中，&#x3D;&#x3D;白色是文件，蓝色是文件夹&#x3D;&#x3D;</p>
<h3 id="3-1目录管理"><a href="#3-1目录管理" class="headerlink" title="3.1目录管理"></a>3.1目录管理</h3><blockquote>
<p>绝对路径，相对路径</p>
</blockquote>
<p>绝对路径：路径的全程   D:\nmap\licenses\xxx.xx</p>
<p>相对路径：D:\nmap\licenses     比如在这个licence目录下  这个xxx.xx文件，对应我们的相对配置&#x2F;xxx.xx</p>
<p>cd (change directory) :切换目录命令</p>
<p>cd  .. ：返回上一个目录</p>
<p>.&#x2F;   :当前目录</p>
<blockquote>
<p>ls（列出目录）</p>
</blockquote>
<p>在Linux中，ls可能是常常被使用的</p>
<p>-a参数：all，查看全部的文件，包括隐藏的文件</p>
<p>-l参数：列出所有的文件，包括文件的属性和权限，不会列出隐藏文件</p>
<p>所有Linux命令可以组合使用</p>
<blockquote>
<p>cd命令（切换目录）</p>
</blockquote>
<p>cd 目录名（绝对路径：绝对路径都是以&#x2F;开头，相对路径：对于当前目录应该如何寻找  .. 上一级目录  ..&#x2F;.. 上上级目录）</p>
<blockquote>
<p>pwd （print working directory    显示当前用户所在的目录）</p>
</blockquote>
<blockquote>
<p>mkdir  （创建一个目录）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir Mytest/test1</span></span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘Mytest/test1’: No such file or directory</span><br><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir -p Mytest/test1</span></span><br></pre></td></tr></table></figure>

<p>无法像第一行那样创建多级目录，要用-p 命令进行循环即可创建成功</p>
<blockquote>
<p>rmdir （remove directory）删除目录</p>
</blockquote>
<p>删除目录必须要使文件夹为空      加上-p参数可以循环删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir Mytest/test1</span></span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘Mytest/test1’: No such file or directory</span><br><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir -p Mytest/test1 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>cp（复制文件或者目录）</p>
</blockquote>
<p>命令格式   cp  要拷贝的文件名称   拷贝到的文件夹名称</p>
<p>拷贝相同的文件到相同的位置：会提示你是否覆盖之前的文件</p>
<blockquote>
<p>rm（移除文件或者目录）</p>
</blockquote>
<p>-f  ：force  忽略不存在的文件，不会出现警告，强制删除文件</p>
<p>-r ： recursive   递归删除目录，意味着该选项允许命令作用于目录及其包含的所有子目录和文件</p>
<p>-i：interact  互动，删除时询问是否删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /   <span class="comment">#系统中的所有文件都被删除了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mv 移动文件或者目录，或者重命名文件</p>
</blockquote>
<p>-f  ：强制移动</p>
<p>-u： update  只替换已经更新过的文件</p>
<h3 id="3-2基本属性"><a href="#3-2基本属性" class="headerlink" title="3.2基本属性"></a>3.2基本属性</h3><p><img src="https://www.freeimg.cn/i/2024/05/06/6638732aa57e5.jpg" alt="https://www.freeimg.cn/i/2024/05/06/6638732aa57e5.jpg"></p>
<p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p><strong>b</strong> 表示 <strong>块设备文件</strong>（Block Device File）。这类文件用于存储设备，允许随机访问数据。块设备可以一次传输和处理多个数据块，而不是单个字节，这使得它们非常适合硬盘、SSD等存储媒介，因为这些设备上的数据读写通常以块的形式进行。</p>
<p><strong>c</strong> 表示 <strong>字符设备文件</strong>（Character Device File）。这类文件代表了系统中的串行端口设备，数据读写是以字符流的形式（一次一个字符或一组字符）进行，适用于像键盘、鼠标这样的设备，以及串行通信端口等，它们通常按顺序读取或发送数据。</p>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>&#x3D;&#x3D;要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。&#x3D;&#x3D;</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<p><img src="https://www.freeimg.cn/i/2024/05/06/6638734f69deb.jpg" alt="https://www.freeimg.cn/i/2024/05/06/6638734f69deb.jpg"></p>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<p><strong>1、chgrp：(change  group)更改文件属组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：(change  owner)更改文件属主，也可以同时更改文件属组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [–R] 属主名 文件名</span><br><span class="line"><span class="built_in">chown</span> [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;**3.chmod：（modify）更改文件的九个属性（必须要掌握） **&#x3D;&#x3D;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 770 filename   <span class="comment">#将文件名为filename的文件赋予属主，属组，其他用户  读写执行权限</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3文件内容查看"><a href="#3-3文件内容查看" class="headerlink" title="3.3文件内容查看"></a>3.3文件内容查看</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tac</p>
</blockquote>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]<span class="comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>



<blockquote>
<p>nl  显示行号</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]<span class="comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">1DEVICE=eth0</span><br><span class="line">2BOOTPROTO=dhcp</span><br><span class="line">3ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>more  一页一页翻动</p>
</blockquote>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter   ：代表向下翻『一行』；</li>
<li>&#x2F;字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f    ：立刻显示出档名以及目前显示的行数；</li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) <span class="comment"># 重点在这一行喔！你的光标也会在这里等待你的命令</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>less  一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p>
</blockquote>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串  ：向下搜寻『字串』的功能；</li>
<li>?字串  ：向上搜寻『字串』的功能；</li>
<li>n   ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q   ：离开 less 这个程序；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">:   <span class="comment"># 这里可以等待你输入命令！</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>head  取出文件前面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># head -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>tail  取出文件后面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># tail -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>拓展：Linux 链接概念</p>
</blockquote>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p>
<p>情况下，<strong>ln</strong> 命令产生硬链接。</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong></p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen /]<span class="comment"># cd /home</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># touch f1 # 创建一个测试文件f1</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># ls</span></span><br><span class="line">f1</span><br><span class="line">[root@kuangshen home]<span class="comment"># ln f1 f2     # 创建f1的一个硬连接文件f2</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># ln -s f1 f3   # 创建f1的一个符号连接文件f3</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># ls -li       # -i参数显示文件的inode节点信息</span></span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># echo &quot;I am f1 file&quot; &gt;&gt;f1</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f1</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f3</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># rm -f f1</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f3</span></span><br><span class="line"><span class="built_in">cat</span>: f3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h3 id="3-4-Vim使用"><a href="#3-4-Vim使用" class="headerlink" title="3.4 Vim使用"></a>3.4 Vim使用</h3><blockquote>
<p>什么是Vim编辑器</p>
</blockquote>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p>
<p>vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4RsQuEaoMI78gr3jGxkVH7ONWyDHmremOHiaUibc3sqPRfEuVuHqicfqA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>三种使用模式</p>
</blockquote>
<p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command ）</strong>，<strong>输入模式（Insert ）</strong>和<strong>底线命令模式（Last line ）</strong>。这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong></p>
<p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<p><strong>输入模式：</strong></p>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li>
<li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li>
<li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<p><strong>底线命令模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMIxVoDyQ4LWxSbHDjAYfHuId7xfHHichtqZK2ehsXvcC9KiaibPf68s9dg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>上手体验一下，在home目录下测试</p>
</blockquote>
<p>如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen home]<span class="comment"># vim kuangstudy.txt</span></span><br></pre></td></tr></table></figure>

<p>然后就会进入文件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4461hqusRbQZ32967zqUhChqXbCzJTN3I20RpiaVbFqWvHicvicc9icBUQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMEarICtkr8ia1N6zqcuv3ROj1TBDoMicM5DoYzaGU29qQ2mbQhlBUbbww/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>按下 ESC 按钮回到一般模式</strong></p>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<p>在一般模式中按下 <strong>:wq</strong> 储存后离开 vim！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMeA5EoVUt4j2544oibjdoeRah06s2ALh1QDXwep41Mj4ZnhWyb6icdp0w/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。</p>
<blockquote>
<p>Vim 按键说明</p>
</blockquote>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p>
<table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n&lt; space&gt;</td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td align="left">n&lt; Enter&gt;</td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;一般向上搜索的时候不用  ？word   先用&#x2F;word向下搜索，向上搜索的时候直接n，向下搜索N&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th align="left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody></table>
<p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;i, I&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;进入输入模式(Insert )：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert )：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert )：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace )：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;:set nu&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;显示行号，设定之后，会在每一行的前缀显示该行的行号&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<h3 id="3-5账号管理"><a href="#3-5账号管理" class="headerlink" title="3.5账号管理"></a>3.5账号管理</h3><blockquote>
<p>简介</p>
</blockquote>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<blockquote>
<p>用户账号的管理</p>
</blockquote>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<blockquote>
<p>添加账号 useradd</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>选项 :<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-m　使用者目录如不存在则自动建立。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li>用户名 :<ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># useradd -m kuangshen</span></span><br></pre></td></tr></table></figure>

<p>增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p>
<blockquote>
<p>Linux下如何切换用户</p>
</blockquote>
<p>1.切换用户的命令为：su username 【username是你的用户名哦】</p>
<p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p>
<p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p>
<p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p>
<p>$表示普通用户</p>
<p>#表示超级用户，也就是root用户</p>
<blockquote>
<p>删除帐号</p>
</blockquote>
<p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen home]<span class="comment"># userdel -r kuangshen</span></span><br></pre></td></tr></table></figure>

<p>此命令删除用户kuangshen在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。</p>
<blockquote>
<p>修改帐号</p>
</blockquote>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usermod -s /bin/ksh -d /home/z –g developer kuangshen</span></span><br></pre></td></tr></table></figure>

<p>此命令将用户kuangshen的登录Shell修改为ksh，主目录改为&#x2F;home&#x2F;z，用户组改为developer。</p>
<blockquote>
<p>用户口令的管理</p>
</blockquote>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p>
<p>命令的格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">Old password:******</span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd kuangshen</span></span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd -d kuangshen</span></span><br></pre></td></tr></table></figure>

<p>此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd -l kuangshen</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6用户组管理"><a href="#3-6用户组管理" class="headerlink" title="3.6用户组管理"></a>3.6用户组管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。</p>
<blockquote>
<p>增加一个新的用户组使用groupadd命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd group1</span></span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd -g 101 group2</span></span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<blockquote>
<p>如果要删除一个已有的用户组，使用groupdel命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupdel group1</span></span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<blockquote>
<p>修改用户组的属性使用groupmod命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令将组group2的组标识号修改为102。</span></span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将组group2的标识号改为10000，组名修改为group3。</span></span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>切换组</p>
</blockquote>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<blockquote>
<p>&#x2F;etc&#x2F;passwd</p>
</blockquote>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p><strong>&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<p>Linux系统中的每个用户都在&#x2F;etc&#x2F;passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<p>1）”用户名”是代表用户账号的字符串。</p>
<p>通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">伪 用 户 含 义</span><br><span class="line">bin 拥有可执行的用户命令文件</span><br><span class="line">sys 拥有系统文件</span><br><span class="line">adm 拥有帐户文件</span><br><span class="line">uucp UUCP使用</span><br><span class="line">lp lp或lpd子系统使用</span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;etc&#x2F;shadow</p>
</blockquote>
<p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生</strong></p>
<p>它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<blockquote>
<p>&#x2F;etc&#x2F;group</p>
</blockquote>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li><p>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。</p>
</li>
<li><p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p>
</li>
<li><p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</p>
</li>
<li><p>“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p>
</li>
</ol>
<h3 id="3-7磁盘管理"><a href="#3-7磁盘管理" class="headerlink" title="3.7磁盘管理"></a>3.7磁盘管理</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量  （disk  free）</li>
<li>du：检查磁盘空间使用量       （disk  usage）</li>
</ul>
<blockquote>
<p>df</p>
</blockquote>
<p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；   human-readable</li>
<li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将系统内所有的文件系统列出来！</span></span><br><span class="line"><span class="comment"># 在 Linux 底下如果 df 没有加任何选项</span></span><br><span class="line"><span class="comment"># 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks   Used Available Use% Mounted on</span><br><span class="line">devtmpfs          889100       0    889100   0% /dev</span><br><span class="line">tmpfs             899460     704    898756   1% /dev/shm</span><br><span class="line">tmpfs             899460     496    898964   1% /run</span><br><span class="line">tmpfs             899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       41152812 6586736  32662368  17% /</span><br><span class="line">tmpfs             179896       0    179896   0% /run/user/0</span><br><span class="line"><span class="comment"># 将容量结果以易读的容量格式显示出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       869M     0 869M   0% /dev</span><br><span class="line">tmpfs           879M 708K 878M   1% /dev/shm</span><br><span class="line">tmpfs           879M 496K 878M   1% /run</span><br><span class="line">tmpfs           879M     0 879M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br><span class="line">tmpfs           176M     0 176M   0% /run/user/0</span><br><span class="line"><span class="comment"># 将系统内的所有特殊文件格式及名称都列出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -aT</span></span><br><span class="line">Filesystem     Type       1K-blocks   Used Available Use% Mounted on</span><br><span class="line">sysfs         sysfs               0       0         0    - /sys</span><br><span class="line">proc           proc                0       0         0    - /proc</span><br><span class="line">devtmpfs       devtmpfs       889100       0    889100   0% /dev</span><br><span class="line">securityfs     securityfs          0       0         0    - /sys/kernel/security</span><br><span class="line">tmpfs         tmpfs          899460     708    898752   1% /dev/shm</span><br><span class="line">devpts         devpts              0       0         0    - /dev/pts</span><br><span class="line">tmpfs         tmpfs          899460     496    898964   1% /run</span><br><span class="line">tmpfs         tmpfs          899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore         pstore              0       0         0    - /sys/fs/pstore</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/memory</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/perf_event</span><br><span class="line">configfs       configfs            0       0         0    - /sys/kernel/config</span><br><span class="line">/dev/vda1     ext4         41152812 6586748  32662356  17% /</span><br><span class="line">systemd-1      -                   -       -         -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">mqueue         mqueue              0       0         0    - /dev/mqueue</span><br><span class="line">debugfs       debugfs             0       0         0    - /sys/kernel/debug</span><br><span class="line">hugetlbfs     hugetlbfs           0       0         0    - /dev/hugepages</span><br><span class="line">tmpfs         tmpfs          179896       0    179896   0% /run/user/0</span><br><span class="line">binfmt_misc   binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc</span><br><span class="line"><span class="comment"># 将 /etc 底下的可用的磁盘容量以易读的容量格式显示</span></span><br><span class="line"></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h /etc</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br></pre></td></tr></table></figure>



<blockquote>
<p>du</p>
</blockquote>
<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</span></span><br><span class="line"><span class="comment"># 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du</span></span><br><span class="line">16./redis</span><br><span class="line">8./www/.oracle_jre_usage  <span class="comment"># 包括隐藏文件的目录</span></span><br><span class="line">24./www</span><br><span class="line">48.                        <span class="comment"># 这个目录(.)所占用的总量</span></span><br><span class="line"><span class="comment"># 将文件的容量也列出来</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -a</span></span><br><span class="line">4./redis/.bash_profile</span><br><span class="line">4./redis/.bash_logout    </span><br><span class="line">....中间省略....</span><br><span class="line">4./kuangstudy.txt <span class="comment"># 有文件的列表了</span></span><br><span class="line">48.</span><br><span class="line"><span class="comment"># 检查根目录底下每个目录所占用的容量</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -sm /*</span></span><br><span class="line">0/bin</span><br><span class="line">146/boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0/proc</span><br><span class="line">.....中间省略....</span><br><span class="line">1/tmp</span><br><span class="line">3026/usr  <span class="comment"># 系统初期最大就是他了啦！</span></span><br><span class="line">513/var</span><br><span class="line">2666/www</span><br></pre></td></tr></table></figure>

<p>通配符 * 来代表每个目录。</p>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<blockquote>
<p>磁盘挂载与卸除</p>
</blockquote>
<p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p>
<p>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。</p>
<p>磁盘挂载语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！</span></span><br><span class="line">[root@www ~]<span class="comment"># mkdir /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># mount /dev/hdc6 /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># df</span></span><br><span class="line">Filesystem           1K-blocks     Used Available Use% Mounted on</span><br><span class="line">/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6</span><br></pre></td></tr></table></figure>

<p>磁盘卸载命令 umount 语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li>
<li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。</li>
</ul>
<p>卸载&#x2F;dev&#x2F;hdc6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># umount /dev/hdc6</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8进程管理"><a href="#3-8进程管理" class="headerlink" title="3.8进程管理"></a>3.8进程管理</h3><blockquote>
<p>Linux下进程的基本概念</p>
</blockquote>
<p>1.在Linux中，每一个程序都有一个自己的进程，每一个进程都有一个id号</p>
<p>2.每一个进程，都会有一个父进程</p>
<p>3.进程可以有两种存在方式：前台（页面不能关闭，关闭就结束了）   后台（页面存在与否，进程都不会结束）</p>
<p>4.一般的话，服务都是后台运行的，基本的程序都是前台运行的</p>
<blockquote>
<p>命令</p>
</blockquote>
<p><strong>ps</strong>：(Process status) 查看当前系统中正在执行的各种进程的信息</p>
<p>ps -help  或者  man  ps：查看帮助文档      man：manual  手册</p>
<p>ps -xx：</p>
<ul>
<li><p>-a  显示当前终端运行的所有进程信息（当前的进程，只有一个）</p>
</li>
<li><p>-u 以用户的信息显示进程</p>
</li>
<li><p>-x     显示后台运行进程的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux  <span class="comment">#查看所有的进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   |   在linux中这个叫做管道符   A|B   可以把A命令的结果作为输出操作B命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#grep  global regular expression print查找文件中符合条件的字符串</span></span><br><span class="line"></span><br><span class="line">ps -aux|grep mysql  <span class="comment">#只查看和mysql相关的进程，过滤其他的进程</span></span><br></pre></td></tr></table></figure>

<p><strong>ps-ef</strong>：可以查看到父进程的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep  mysql   <span class="comment">#看父进程我们一般可以通过目录树来查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程树</span></span><br><span class="line">pstree -pu</span><br><span class="line">	-p  显示父<span class="built_in">id</span></span><br><span class="line">	-u  显示当前的用户组</span><br></pre></td></tr></table></figure>

<p><img src="https://www.freeimg.cn/i/2024/05/07/6639f1ba9cdd6.png" alt="https://www.freeimg.cn/i/2024/05/07/6639f1ba9cdd6.png"></p>
<p>结束进程：杀掉进程，等于Windows结束任务</p>
</li>
</ul>
<p>kill -9  所需结束进程的id</p>
<p>但是，我们平时写的一个java代码死循环了，可以选择结束进程</p>
<h2 id="4-环境安装"><a href="#4-环境安装" class="headerlink" title="4.环境安装"></a>4.环境安装</h2><p>安装软件一般有三种方式：</p>
<ul>
<li>rpm（jdk：在线发布一个SpringBoot项目）</li>
<li>解压缩（tomcat，启动并通过外网访问，发布网站）</li>
<li>yum在线安装（docker：直接安装运行跑起来docker即可）</li>
</ul>
<p>RPM（Red Hat Package Manager）是一种Linux下的软件包管理器，最初由Red Hat公司开发，但现在广泛应用于各种基于RPM的Linux发行版中。RPM软件包通常以<code>.rpm</code>作为文件扩展名，包含应用程序的可执行文件、库文件、配置文件以及其他元数据（如软件版本、依赖关系等）。使用RPM工具，用户可以直接安装、升级、查询或卸载这些软件包。然而，RPM在处理软件包依赖性问题时可能较为繁琐，尤其是当需要安装的软件依赖于多个其他软件包时。</p>
<p>YUM（Yellowdog Updater, Modified）是建立在RPM之上的一个更高级的包管理器，主要用于Fedora、早期版本的Red Hat Enterprise Linux (RHEL)、CentOS及其他一些基于RPM的Linux发行版中。YUM通过自动从网络仓库中检索软件包及其依赖项来简化软件的安装、更新和移除过程。它能够自动解析并下载安装一个软件包所需要的全部依赖，从而极大地减轻了用户手动处理依赖性的负担。YUM使用配置好的仓库列表来查找和获取软件包，使得软件管理更加高效和便捷。</p>
<p>简而言之，RPM是底层的软件包管理技术，而YUM是基于RPM的更高层次的包管理工具，提供了自动化依赖关系解决和其他便利功能。随着Linux发行版的发展，较新的系统（如RHEL 8及以后）已逐渐迁移到DNF（Dandified Yum）作为默认的包管理器，它在YUM的基础上进一步改进，提供更高效的性能和更多功能。</p>
<h3 id="4-1-JDK安装"><a href="#4-1-JDK安装" class="headerlink" title="4.1 JDK安装"></a>4.1 JDK安装</h3><p>开发Java程序必须要的环境</p>
<p>1.linux jdk8 x64.tar.gz</p>
<p>2.安装java环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	检测当前系统是否存在java环境  java -version</span></span><br><span class="line"><span class="comment">#	如果有的话就需要卸载</span></span><br><span class="line"><span class="comment">#	rpm -qa|grep jdk #检测JDk版本信息</span></span><br><span class="line"><span class="comment">#	rpm -e --nodeps jdk_     e:erase  擦除，抹去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#	卸载完毕后即可安装jdk</span></span><br></pre></td></tr></table></figure>

<p>安装教程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装JDK8</span><br><span class="line"></span><br><span class="line">去http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html中下载JDK的安装文件jdk-8u60-linux-x64.tar.gz。  </span><br><span class="line"></span><br><span class="line">新建/usr/java文件夹，将jdk-8u60-linux-x64.tar.gz放到该文件夹下，并切换到/usr/java目录下。 </span><br><span class="line"></span><br><span class="line">执行命令tar zxvf jdk-8u60-linux-x64.tar.gz进行解压缩，解压后/usr/java目录下多了jdk1.8.0_60文件夹。  </span><br><span class="line"></span><br><span class="line">通过以上步骤，JDK安装完毕。下面开始配置环境变量。</span><br><span class="line"></span><br><span class="line"> 配置环境变量</span><br><span class="line"></span><br><span class="line">执行命令vim /etc/profile编辑profile文件。  </span><br><span class="line"></span><br><span class="line">在/etc/profile底部加入如下内容：    </span><br><span class="line">   	 JAVA_HOME=/usr/java/jdk1.8.0_60    </span><br><span class="line">    	PATH=$JAVA_HOME/bin:$PATH    </span><br><span class="line">    	CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar    </span><br><span class="line">   	 export PATH JAVA_HOME CLASSPATH   </span><br><span class="line"></span><br><span class="line">以上，环境变量配置完成。需要注意的是，PATH在配置的时候，一定要把$JAVA_HOME/bin放在前面，不然使用java命令时，系统会找到以前 的java，再不往下找了。这样java这个可执行文件运行的目录其实不在$JAVA_HOME/bin下，而在其它目录下，会造成很大的问题。 </span><br><span class="line"></span><br><span class="line">执行命令source /etc/profile让profile文件立即生效。</span><br></pre></td></tr></table></figure>

<p><img src="https://www.freeimg.cn/i/2024/05/07/663a40b594fb5.png" alt="https://www.freeimg.cn/i/2024/05/07/663a40b594fb5.png"></p>
<h3 id="4-2Tomcat安装"><a href="#4-2Tomcat安装" class="headerlink" title="4.2Tomcat安装"></a>4.2Tomcat安装</h3><p>ssm war 就需要放到tomcat中运行</p>
<p>1.下载tomcat。官网下载即可  tomcat9  apache-tomcat-9.0.87.tar.gz</p>
<p>2.解压这个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.87.tar.gz</span><br></pre></td></tr></table></figure>

<p>3.启动tomcat测试	.&#x2F;xxx.sh   脚本即可运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行 ./startup.sh</span></span><br><span class="line"><span class="comment">#停止	./shoutdown.sh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tomcat启动成功<img src="https://www.freeimg.cn/i/2024/05/07/663a48b51cf7f.png" alt="https://www.freeimg.cn/i/2024/05/07/663a48b51cf7f.png"></p>
<p>如果防火墙8080端口开了并且阿里云安全组页开放了，这个时候就可以直接访问远程了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看firewall服务状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启、重启、关闭、firewalld.service服务</span></span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all    <span class="comment"># 查看全部信息</span></span><br><span class="line">firewall-cmd --list-ports  <span class="comment"># 只看端口信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启端口</span></span><br><span class="line">开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone <span class="comment">#作用域</span></span><br><span class="line">--add-port=80/tcp  <span class="comment">#添加端口，格式为：端口/通讯协议</span></span><br><span class="line">--permanent   <span class="comment">#永久生效，没有此参数重启后失效</span></span><br></pre></td></tr></table></figure>

<p>域名解析后，如果端口是80-http 或者443-https  可以直接访问，如果是9000 8080，就需要通过Apache或者Nginx做一下方向代理，配置文件即可，</p>
<h3 id="4-3Docker安装"><a href="#4-3Docker安装" class="headerlink" title="4.3Docker安装"></a>4.3Docker安装</h3><p>yum安装：在linux下执行，一定要联网，yum在线安装</p>
<blockquote>
<p>安装</p>
</blockquote>
<p>1.检测centos</p>
<p>cat &#x2F;etc&#x2F;redhat-release    查看服务器的系统版本信息</p>
<p>2.安装我们的准备环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install 包名	<span class="comment">#yum  install   这是安装命令</span></span><br></pre></td></tr></table></figure>

<p>3.清楚先前的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure>

<p>4.安装Docker</p>
<p>Alibaba Cloud Linux 3</p>
<ol>
<li><p>运行以下命令，添加docker-ce的dnf源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf config-manager --add-repo=https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令，安装Alibaba Cloud Linux 3专用的dnf源兼容插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf -y install dnf-plugin-releasever-adapter --repo alinux3-plus</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令，安装Docker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf -y install docker-ce --nobest</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果执行命令时，出现类似如下的报错信息，您需要执行<code>sudo dnf clean packages</code>清除软件包缓存后，重新安装docker-ce。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(8-9/12): docker-ce-24.0.7-1.el8.x86_64.rpm 38% [================- ] 8.2 MB/s | 38 MB 00:07 ETA</span><br><span class="line">The downloaded packages were saved in cache until the next successful transaction.</span><br><span class="line">You can remove cached packages by executing &#x27;dnf clean packages&#x27;.</span><br><span class="line">Error: Error downloading packages:</span><br><span class="line">containerd.io-1.6.26-3.1.el8.x86_64: Cannot download, all mirrors were already tried without success</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果执行命令时，出现类似下图的报错信息，您需要注释&#x2F;etc&#x2F;yum.repos.d下的CentOS源，注释后重新安装docker-ce。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/1286511071/p477222.png" alt="adad566"></p>
</li>
</ul>
</li>
<li><p>执行以下命令，检查Docker是否安装成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo docker -v</span><br></pre></td></tr></table></figure>

<p>如下图回显信息所示，表示Docker已安装成功。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/6489086861/p683254.png" alt="image..png"></p>
</li>
<li><p>执行以下命令，启动Docker服务，并设置开机自启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令，查看Docker是否启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure>

<p>如下图回显所示，表示Docker已启动。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/9710116861/p679571.png" alt="image..png"></p>
</li>
</ol>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
</search>
