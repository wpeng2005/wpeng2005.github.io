<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to my blog</title>
    <url>/2024/06/29/IntroduceMyself/</url>
    <content><![CDATA[<p>致力于java后端开发，分享后端相关知识</p>
]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2024/06/30/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><strong>Linux一切皆文件：文件就读,写  （权限）</strong></p>
<p>学习方式</p>
<ol>
<li>认识linux</li>
<li>基本的命令 （重点：Git讲了一些基本的命令(文件操作，目录管理，文件属性，Vim编辑器,账号管理，磁盘管理,..))</li>
<li>软件的安装和部署(java,tomcat,docker)</li>
</ol>
<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h2><p>云服务器就是一个远程电脑，服务器一般不会关机</p>
<p><img src="https://www.freeimg.cn/i/2024/05/05/663724ddd6665.png" alt="https://www.freeimg.cn/i/2024/05/05/663724ddd6665.png"></p>
<p>登录成功后，这里就是linux操作系统了！以后的操作都在这里操作，项目也在这里发布</p>
<p>ctrl＋鼠标滚轮：放大和缩小字体</p>
<p>xtfp用来上传文件</p>
<p><img src="https://www.freeimg.cn/i/2024/05/05/663767a27188d.png"></p>
<p>如果将本地文件，jar包，安装包等等，放到Linux只需要将左边的文件拖到右边就可以了</p>
<p>使用Tomcat需要安装java环境</p>
<p>xshell命令   ls-ll   竖列列出</p>
<p>​	</p>
<h2 id="2-走进Linux系统"><a href="#2-走进Linux系统" class="headerlink" title="2.走进Linux系统"></a>2.走进Linux系统</h2><blockquote>
<p>开机登录</p>
</blockquote>
<p>开机会启动许多程序，他们在Windows叫做服务(service)，在Linux就叫做守护进程（daemon）</p>
<p><strong>linux里面如果没有输出错误，即代表成功</strong></p>
<p>一般来说，用户的登陆方式有三种：</p>
<ul>
<li>命令行登录</li>
<li>ssh登录</li>
<li>图形界面登录</li>
</ul>
<p>最高权限账户为root，可以操作一切</p>
<blockquote>
<p>系统目录结构</p>
</blockquote>
<p><strong>1.一切皆文件</strong></p>
<p><strong>2.根目录&#x2F;，所有的文件都挂载在这个节点下</strong></p>
<p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><strong>&#x2F;bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>&#x2F;boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>&#x2F;dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>&#x2F;home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。&#x3D;&#x3D;</li>
<li><strong>&#x2F;lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li>
<li><strong>&#x2F;lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><strong>&#x2F;media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>&#x2F;mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。&#x3D;&#x3D;</li>
<li><strong>&#x2F;proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。&#x3D;&#x3D;</li>
<li><strong>&#x2F;sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>&#x2F;srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>&#x2F;sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;tmp</strong>：这个目录是用来存放一些临时文件的。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>&#x2F;usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。&#x3D;&#x3D;</li>
<li><strong>&#x2F;usr&#x2F;bin：</strong> 系统用户使用的应用程序。</li>
<li><strong>&#x2F;usr&#x2F;sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>&#x2F;usr&#x2F;src：</strong> 内核源代码默认的放置目录。</li>
<li>&#x3D;&#x3D;<strong>&#x2F;var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。&#x3D;&#x3D;</li>
<li><strong>&#x2F;run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
<li>&#x3D;&#x3D;&#x2F;www：存放服务器网站相关的资源，环境，网站的项目&#x3D;&#x3D;</li>
</ul>
<h2 id="3-常用的基本命令"><a href="#3-常用的基本命令" class="headerlink" title="3.常用的基本命令"></a>3.常用的基本命令</h2><p>在命令行中，&#x3D;&#x3D;白色是文件，蓝色是文件夹&#x3D;&#x3D;</p>
<h3 id="3-1目录管理"><a href="#3-1目录管理" class="headerlink" title="3.1目录管理"></a>3.1目录管理</h3><blockquote>
<p>绝对路径，相对路径</p>
</blockquote>
<p>绝对路径：路径的全程   D:\nmap\licenses\xxx.xx</p>
<p>相对路径：D:\nmap\licenses     比如在这个licence目录下  这个xxx.xx文件，对应我们的相对配置&#x2F;xxx.xx</p>
<p>cd (change directory) :切换目录命令</p>
<p>cd  .. ：返回上一个目录</p>
<p>.&#x2F;   :当前目录</p>
<blockquote>
<p>ls（列出目录）</p>
</blockquote>
<p>在Linux中，ls可能是常常被使用的</p>
<p>-a参数：all，查看全部的文件，包括隐藏的文件</p>
<p>-l参数：列出所有的文件，包括文件的属性和权限，不会列出隐藏文件</p>
<p>所有Linux命令可以组合使用</p>
<blockquote>
<p>cd命令（切换目录）</p>
</blockquote>
<p>cd 目录名（绝对路径：绝对路径都是以&#x2F;开头，相对路径：对于当前目录应该如何寻找  .. 上一级目录  ..&#x2F;.. 上上级目录）</p>
<blockquote>
<p>pwd （print working directory    显示当前用户所在的目录）</p>
</blockquote>
<blockquote>
<p>mkdir  （创建一个目录）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir Mytest/test1</span></span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘Mytest/test1’: No such file or directory</span><br><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir -p Mytest/test1</span></span><br></pre></td></tr></table></figure>

<p>无法像第一行那样创建多级目录，要用-p 命令进行循环即可创建成功</p>
<blockquote>
<p>rmdir （remove directory）删除目录</p>
</blockquote>
<p>删除目录必须要使文件夹为空      加上-p参数可以循环删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir Mytest/test1</span></span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘Mytest/test1’: No such file or directory</span><br><span class="line">[root@iZbp161cl74u47j9ts8139Z home]<span class="comment"># mkdir -p Mytest/test1 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>cp（复制文件或者目录）</p>
</blockquote>
<p>命令格式   cp  要拷贝的文件名称   拷贝到的文件夹名称</p>
<p>拷贝相同的文件到相同的位置：会提示你是否覆盖之前的文件</p>
<blockquote>
<p>rm（移除文件或者目录）</p>
</blockquote>
<p>-f  ：force  忽略不存在的文件，不会出现警告，强制删除文件</p>
<p>-r ： recursive   递归删除目录，意味着该选项允许命令作用于目录及其包含的所有子目录和文件</p>
<p>-i：interact  互动，删除时询问是否删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /   <span class="comment">#系统中的所有文件都被删除了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mv 移动文件或者目录，或者重命名文件</p>
</blockquote>
<p>-f  ：强制移动</p>
<p>-u： update  只替换已经更新过的文件</p>
<h3 id="3-2基本属性"><a href="#3-2基本属性" class="headerlink" title="3.2基本属性"></a>3.2基本属性</h3><p><img src="https://www.freeimg.cn/i/2024/05/06/6638732aa57e5.jpg" alt="https://www.freeimg.cn/i/2024/05/06/6638732aa57e5.jpg"></p>
<p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p><strong>b</strong> 表示 <strong>块设备文件</strong>（Block Device File）。这类文件用于存储设备，允许随机访问数据。块设备可以一次传输和处理多个数据块，而不是单个字节，这使得它们非常适合硬盘、SSD等存储媒介，因为这些设备上的数据读写通常以块的形式进行。</p>
<p><strong>c</strong> 表示 <strong>字符设备文件</strong>（Character Device File）。这类文件代表了系统中的串行端口设备，数据读写是以字符流的形式（一次一个字符或一组字符）进行，适用于像键盘、鼠标这样的设备，以及串行通信端口等，它们通常按顺序读取或发送数据。</p>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>&#x3D;&#x3D;要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。&#x3D;&#x3D;</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<p><img src="https://www.freeimg.cn/i/2024/05/06/6638734f69deb.jpg" alt="https://www.freeimg.cn/i/2024/05/06/6638734f69deb.jpg"></p>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<p><strong>1、chgrp：(change  group)更改文件属组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：(change  owner)更改文件属主，也可以同时更改文件属组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [–R] 属主名 文件名</span><br><span class="line"><span class="built_in">chown</span> [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;**3.chmod：（modify）更改文件的九个属性（必须要掌握） **&#x3D;&#x3D;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 770 filename   <span class="comment">#将文件名为filename的文件赋予属主，属组，其他用户  读写执行权限</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3文件内容查看"><a href="#3-3文件内容查看" class="headerlink" title="3.3文件内容查看"></a>3.3文件内容查看</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tac</p>
</blockquote>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]<span class="comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>



<blockquote>
<p>nl  显示行号</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]<span class="comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">1DEVICE=eth0</span><br><span class="line">2BOOTPROTO=dhcp</span><br><span class="line">3ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>more  一页一页翻动</p>
</blockquote>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter   ：代表向下翻『一行』；</li>
<li>&#x2F;字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f    ：立刻显示出档名以及目前显示的行数；</li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) <span class="comment"># 重点在这一行喔！你的光标也会在这里等待你的命令</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>less  一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p>
</blockquote>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串  ：向下搜寻『字串』的功能；</li>
<li>?字串  ：向上搜寻『字串』的功能；</li>
<li>n   ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q   ：离开 less 这个程序；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">:   <span class="comment"># 这里可以等待你输入命令！</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>head  取出文件前面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># head -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>tail  取出文件后面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]<span class="comment"># tail -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>拓展：Linux 链接概念</p>
</blockquote>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p>
<p>情况下，<strong>ln</strong> 命令产生硬链接。</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong></p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen /]<span class="comment"># cd /home</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># touch f1 # 创建一个测试文件f1</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># ls</span></span><br><span class="line">f1</span><br><span class="line">[root@kuangshen home]<span class="comment"># ln f1 f2     # 创建f1的一个硬连接文件f2</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># ln -s f1 f3   # 创建f1的一个符号连接文件f3</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># ls -li       # -i参数显示文件的inode节点信息</span></span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># echo &quot;I am f1 file&quot; &gt;&gt;f1</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f1</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f3</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># rm -f f1</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]<span class="comment"># cat f3</span></span><br><span class="line"><span class="built_in">cat</span>: f3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h3 id="3-4-Vim使用"><a href="#3-4-Vim使用" class="headerlink" title="3.4 Vim使用"></a>3.4 Vim使用</h3><blockquote>
<p>什么是Vim编辑器</p>
</blockquote>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p>
<p>vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4RsQuEaoMI78gr3jGxkVH7ONWyDHmremOHiaUibc3sqPRfEuVuHqicfqA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>三种使用模式</p>
</blockquote>
<p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command ）</strong>，<strong>输入模式（Insert ）</strong>和<strong>底线命令模式（Last line ）</strong>。这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong></p>
<p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<p><strong>输入模式：</strong></p>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li>
<li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li>
<li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<p><strong>底线命令模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMIxVoDyQ4LWxSbHDjAYfHuId7xfHHichtqZK2ehsXvcC9KiaibPf68s9dg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>上手体验一下，在home目录下测试</p>
</blockquote>
<p>如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen home]<span class="comment"># vim kuangstudy.txt</span></span><br></pre></td></tr></table></figure>

<p>然后就会进入文件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4461hqusRbQZ32967zqUhChqXbCzJTN3I20RpiaVbFqWvHicvicc9icBUQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMEarICtkr8ia1N6zqcuv3ROj1TBDoMicM5DoYzaGU29qQ2mbQhlBUbbww/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>按下 ESC 按钮回到一般模式</strong></p>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<p>在一般模式中按下 <strong>:wq</strong> 储存后离开 vim！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMeA5EoVUt4j2544oibjdoeRah06s2ALh1QDXwep41Mj4ZnhWyb6icdp0w/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。</p>
<blockquote>
<p>Vim 按键说明</p>
</blockquote>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p>
<table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n&lt; space&gt;</td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td align="left">n&lt; Enter&gt;</td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;一般向上搜索的时候不用  ？word   先用&#x2F;word向下搜索，向上搜索的时候直接n，向下搜索N&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th align="left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody></table>
<p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;i, I&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;进入输入模式(Insert )：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert )：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert )：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace )：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;:set nu&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;显示行号，设定之后，会在每一行的前缀显示该行的行号&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<h3 id="3-5账号管理"><a href="#3-5账号管理" class="headerlink" title="3.5账号管理"></a>3.5账号管理</h3><blockquote>
<p>简介</p>
</blockquote>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<blockquote>
<p>用户账号的管理</p>
</blockquote>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<blockquote>
<p>添加账号 useradd</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>选项 :<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-m　使用者目录如不存在则自动建立。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li>用户名 :<ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># useradd -m kuangshen</span></span><br></pre></td></tr></table></figure>

<p>增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p>
<blockquote>
<p>Linux下如何切换用户</p>
</blockquote>
<p>1.切换用户的命令为：su username 【username是你的用户名哦】</p>
<p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p>
<p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p>
<p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p>
<p>$表示普通用户</p>
<p>#表示超级用户，也就是root用户</p>
<blockquote>
<p>删除帐号</p>
</blockquote>
<p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen home]<span class="comment"># userdel -r kuangshen</span></span><br></pre></td></tr></table></figure>

<p>此命令删除用户kuangshen在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。</p>
<blockquote>
<p>修改帐号</p>
</blockquote>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usermod -s /bin/ksh -d /home/z –g developer kuangshen</span></span><br></pre></td></tr></table></figure>

<p>此命令将用户kuangshen的登录Shell修改为ksh，主目录改为&#x2F;home&#x2F;z，用户组改为developer。</p>
<blockquote>
<p>用户口令的管理</p>
</blockquote>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p>
<p>命令的格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">Old password:******</span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd kuangshen</span></span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd -d kuangshen</span></span><br></pre></td></tr></table></figure>

<p>此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd -l kuangshen</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6用户组管理"><a href="#3-6用户组管理" class="headerlink" title="3.6用户组管理"></a>3.6用户组管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。</p>
<blockquote>
<p>增加一个新的用户组使用groupadd命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd group1</span></span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd -g 101 group2</span></span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<blockquote>
<p>如果要删除一个已有的用户组，使用groupdel命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupdel group1</span></span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<blockquote>
<p>修改用户组的属性使用groupmod命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令将组group2的组标识号修改为102。</span></span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将组group2的标识号改为10000，组名修改为group3。</span></span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>切换组</p>
</blockquote>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<blockquote>
<p>&#x2F;etc&#x2F;passwd</p>
</blockquote>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p><strong>&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<p>Linux系统中的每个用户都在&#x2F;etc&#x2F;passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<p>1）”用户名”是代表用户账号的字符串。</p>
<p>通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">伪 用 户 含 义</span><br><span class="line">bin 拥有可执行的用户命令文件</span><br><span class="line">sys 拥有系统文件</span><br><span class="line">adm 拥有帐户文件</span><br><span class="line">uucp UUCP使用</span><br><span class="line">lp lp或lpd子系统使用</span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;etc&#x2F;shadow</p>
</blockquote>
<p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生</strong></p>
<p>它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<blockquote>
<p>&#x2F;etc&#x2F;group</p>
</blockquote>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li><p>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。</p>
</li>
<li><p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p>
</li>
<li><p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</p>
</li>
<li><p>“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p>
</li>
</ol>
<h3 id="3-7磁盘管理"><a href="#3-7磁盘管理" class="headerlink" title="3.7磁盘管理"></a>3.7磁盘管理</h3><blockquote>
<p>概述</p>
</blockquote>
<p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量  （disk  free）</li>
<li>du：检查磁盘空间使用量       （disk  usage）</li>
</ul>
<blockquote>
<p>df</p>
</blockquote>
<p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；   human-readable</li>
<li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将系统内所有的文件系统列出来！</span></span><br><span class="line"><span class="comment"># 在 Linux 底下如果 df 没有加任何选项</span></span><br><span class="line"><span class="comment"># 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks   Used Available Use% Mounted on</span><br><span class="line">devtmpfs          889100       0    889100   0% /dev</span><br><span class="line">tmpfs             899460     704    898756   1% /dev/shm</span><br><span class="line">tmpfs             899460     496    898964   1% /run</span><br><span class="line">tmpfs             899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       41152812 6586736  32662368  17% /</span><br><span class="line">tmpfs             179896       0    179896   0% /run/user/0</span><br><span class="line"><span class="comment"># 将容量结果以易读的容量格式显示出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       869M     0 869M   0% /dev</span><br><span class="line">tmpfs           879M 708K 878M   1% /dev/shm</span><br><span class="line">tmpfs           879M 496K 878M   1% /run</span><br><span class="line">tmpfs           879M     0 879M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br><span class="line">tmpfs           176M     0 176M   0% /run/user/0</span><br><span class="line"><span class="comment"># 将系统内的所有特殊文件格式及名称都列出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -aT</span></span><br><span class="line">Filesystem     Type       1K-blocks   Used Available Use% Mounted on</span><br><span class="line">sysfs         sysfs               0       0         0    - /sys</span><br><span class="line">proc           proc                0       0         0    - /proc</span><br><span class="line">devtmpfs       devtmpfs       889100       0    889100   0% /dev</span><br><span class="line">securityfs     securityfs          0       0         0    - /sys/kernel/security</span><br><span class="line">tmpfs         tmpfs          899460     708    898752   1% /dev/shm</span><br><span class="line">devpts         devpts              0       0         0    - /dev/pts</span><br><span class="line">tmpfs         tmpfs          899460     496    898964   1% /run</span><br><span class="line">tmpfs         tmpfs          899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore         pstore              0       0         0    - /sys/fs/pstore</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/memory</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/perf_event</span><br><span class="line">configfs       configfs            0       0         0    - /sys/kernel/config</span><br><span class="line">/dev/vda1     ext4         41152812 6586748  32662356  17% /</span><br><span class="line">systemd-1      -                   -       -         -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">mqueue         mqueue              0       0         0    - /dev/mqueue</span><br><span class="line">debugfs       debugfs             0       0         0    - /sys/kernel/debug</span><br><span class="line">hugetlbfs     hugetlbfs           0       0         0    - /dev/hugepages</span><br><span class="line">tmpfs         tmpfs          179896       0    179896   0% /run/user/0</span><br><span class="line">binfmt_misc   binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc</span><br><span class="line"><span class="comment"># 将 /etc 底下的可用的磁盘容量以易读的容量格式显示</span></span><br><span class="line"></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h /etc</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br></pre></td></tr></table></figure>



<blockquote>
<p>du</p>
</blockquote>
<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</span></span><br><span class="line"><span class="comment"># 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du</span></span><br><span class="line">16./redis</span><br><span class="line">8./www/.oracle_jre_usage  <span class="comment"># 包括隐藏文件的目录</span></span><br><span class="line">24./www</span><br><span class="line">48.                        <span class="comment"># 这个目录(.)所占用的总量</span></span><br><span class="line"><span class="comment"># 将文件的容量也列出来</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -a</span></span><br><span class="line">4./redis/.bash_profile</span><br><span class="line">4./redis/.bash_logout    </span><br><span class="line">....中间省略....</span><br><span class="line">4./kuangstudy.txt <span class="comment"># 有文件的列表了</span></span><br><span class="line">48.</span><br><span class="line"><span class="comment"># 检查根目录底下每个目录所占用的容量</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -sm /*</span></span><br><span class="line">0/bin</span><br><span class="line">146/boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0/proc</span><br><span class="line">.....中间省略....</span><br><span class="line">1/tmp</span><br><span class="line">3026/usr  <span class="comment"># 系统初期最大就是他了啦！</span></span><br><span class="line">513/var</span><br><span class="line">2666/www</span><br></pre></td></tr></table></figure>

<p>通配符 * 来代表每个目录。</p>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<blockquote>
<p>磁盘挂载与卸除</p>
</blockquote>
<p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p>
<p>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。</p>
<p>磁盘挂载语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！</span></span><br><span class="line">[root@www ~]<span class="comment"># mkdir /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># mount /dev/hdc6 /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># df</span></span><br><span class="line">Filesystem           1K-blocks     Used Available Use% Mounted on</span><br><span class="line">/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6</span><br></pre></td></tr></table></figure>

<p>磁盘卸载命令 umount 语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li>
<li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。</li>
</ul>
<p>卸载&#x2F;dev&#x2F;hdc6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># umount /dev/hdc6</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8进程管理"><a href="#3-8进程管理" class="headerlink" title="3.8进程管理"></a>3.8进程管理</h3><blockquote>
<p>Linux下进程的基本概念</p>
</blockquote>
<p>1.在Linux中，每一个程序都有一个自己的进程，每一个进程都有一个id号</p>
<p>2.每一个进程，都会有一个父进程</p>
<p>3.进程可以有两种存在方式：前台（页面不能关闭，关闭就结束了）   后台（页面存在与否，进程都不会结束）</p>
<p>4.一般的话，服务都是后台运行的，基本的程序都是前台运行的</p>
<blockquote>
<p>命令</p>
</blockquote>
<p><strong>ps</strong>：(Process status) 查看当前系统中正在执行的各种进程的信息</p>
<p>ps -help  或者  man  ps：查看帮助文档      man：manual  手册</p>
<p>ps -xx：</p>
<ul>
<li><p>-a  显示当前终端运行的所有进程信息（当前的进程，只有一个）</p>
</li>
<li><p>-u 以用户的信息显示进程</p>
</li>
<li><p>-x     显示后台运行进程的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux  <span class="comment">#查看所有的进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   |   在linux中这个叫做管道符   A|B   可以把A命令的结果作为输出操作B命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#grep  global regular expression print查找文件中符合条件的字符串</span></span><br><span class="line"></span><br><span class="line">ps -aux|grep mysql  <span class="comment">#只查看和mysql相关的进程，过滤其他的进程</span></span><br></pre></td></tr></table></figure>

<p><strong>ps-ef</strong>：可以查看到父进程的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep  mysql   <span class="comment">#看父进程我们一般可以通过目录树来查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程树</span></span><br><span class="line">pstree -pu</span><br><span class="line">	-p  显示父<span class="built_in">id</span></span><br><span class="line">	-u  显示当前的用户组</span><br></pre></td></tr></table></figure>

<p><img src="https://www.freeimg.cn/i/2024/05/07/6639f1ba9cdd6.png" alt="https://www.freeimg.cn/i/2024/05/07/6639f1ba9cdd6.png"></p>
<p>结束进程：杀掉进程，等于Windows结束任务</p>
</li>
</ul>
<p>kill -9  所需结束进程的id</p>
<p>但是，我们平时写的一个java代码死循环了，可以选择结束进程</p>
<h2 id="4-环境安装"><a href="#4-环境安装" class="headerlink" title="4.环境安装"></a>4.环境安装</h2><p>安装软件一般有三种方式：</p>
<ul>
<li>rpm（jdk：在线发布一个SpringBoot项目）</li>
<li>解压缩（tomcat，启动并通过外网访问，发布网站）</li>
<li>yum在线安装（docker：直接安装运行跑起来docker即可）</li>
</ul>
<p>RPM（Red Hat Package Manager）是一种Linux下的软件包管理器，最初由Red Hat公司开发，但现在广泛应用于各种基于RPM的Linux发行版中。RPM软件包通常以<code>.rpm</code>作为文件扩展名，包含应用程序的可执行文件、库文件、配置文件以及其他元数据（如软件版本、依赖关系等）。使用RPM工具，用户可以直接安装、升级、查询或卸载这些软件包。然而，RPM在处理软件包依赖性问题时可能较为繁琐，尤其是当需要安装的软件依赖于多个其他软件包时。</p>
<p>YUM（Yellowdog Updater, Modified）是建立在RPM之上的一个更高级的包管理器，主要用于Fedora、早期版本的Red Hat Enterprise Linux (RHEL)、CentOS及其他一些基于RPM的Linux发行版中。YUM通过自动从网络仓库中检索软件包及其依赖项来简化软件的安装、更新和移除过程。它能够自动解析并下载安装一个软件包所需要的全部依赖，从而极大地减轻了用户手动处理依赖性的负担。YUM使用配置好的仓库列表来查找和获取软件包，使得软件管理更加高效和便捷。</p>
<p>简而言之，RPM是底层的软件包管理技术，而YUM是基于RPM的更高层次的包管理工具，提供了自动化依赖关系解决和其他便利功能。随着Linux发行版的发展，较新的系统（如RHEL 8及以后）已逐渐迁移到DNF（Dandified Yum）作为默认的包管理器，它在YUM的基础上进一步改进，提供更高效的性能和更多功能。</p>
<h3 id="4-1-JDK安装"><a href="#4-1-JDK安装" class="headerlink" title="4.1 JDK安装"></a>4.1 JDK安装</h3><p>开发Java程序必须要的环境</p>
<p>1.linux jdk8 x64.tar.gz</p>
<p>2.安装java环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	检测当前系统是否存在java环境  java -version</span></span><br><span class="line"><span class="comment">#	如果有的话就需要卸载</span></span><br><span class="line"><span class="comment">#	rpm -qa|grep jdk #检测JDk版本信息</span></span><br><span class="line"><span class="comment">#	rpm -e --nodeps jdk_     e:erase  擦除，抹去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#	卸载完毕后即可安装jdk</span></span><br></pre></td></tr></table></figure>

<p>安装教程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装JDK8</span><br><span class="line"></span><br><span class="line">去http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html中下载JDK的安装文件jdk-8u60-linux-x64.tar.gz。  </span><br><span class="line"></span><br><span class="line">新建/usr/java文件夹，将jdk-8u60-linux-x64.tar.gz放到该文件夹下，并切换到/usr/java目录下。 </span><br><span class="line"></span><br><span class="line">执行命令tar zxvf jdk-8u60-linux-x64.tar.gz进行解压缩，解压后/usr/java目录下多了jdk1.8.0_60文件夹。  </span><br><span class="line"></span><br><span class="line">通过以上步骤，JDK安装完毕。下面开始配置环境变量。</span><br><span class="line"></span><br><span class="line"> 配置环境变量</span><br><span class="line"></span><br><span class="line">执行命令vim /etc/profile编辑profile文件。  </span><br><span class="line"></span><br><span class="line">在/etc/profile底部加入如下内容：    </span><br><span class="line">   	 JAVA_HOME=/usr/java/jdk1.8.0_60    </span><br><span class="line">    	PATH=$JAVA_HOME/bin:$PATH    </span><br><span class="line">    	CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar    </span><br><span class="line">   	 export PATH JAVA_HOME CLASSPATH   </span><br><span class="line"></span><br><span class="line">以上，环境变量配置完成。需要注意的是，PATH在配置的时候，一定要把$JAVA_HOME/bin放在前面，不然使用java命令时，系统会找到以前 的java，再不往下找了。这样java这个可执行文件运行的目录其实不在$JAVA_HOME/bin下，而在其它目录下，会造成很大的问题。 </span><br><span class="line"></span><br><span class="line">执行命令source /etc/profile让profile文件立即生效。</span><br></pre></td></tr></table></figure>

<p><img src="https://www.freeimg.cn/i/2024/05/07/663a40b594fb5.png" alt="https://www.freeimg.cn/i/2024/05/07/663a40b594fb5.png"></p>
<h3 id="4-2Tomcat安装"><a href="#4-2Tomcat安装" class="headerlink" title="4.2Tomcat安装"></a>4.2Tomcat安装</h3><p>ssm war 就需要放到tomcat中运行</p>
<p>1.下载tomcat。官网下载即可  tomcat9  apache-tomcat-9.0.87.tar.gz</p>
<p>2.解压这个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.87.tar.gz</span><br></pre></td></tr></table></figure>

<p>3.启动tomcat测试	.&#x2F;xxx.sh   脚本即可运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行 ./startup.sh</span></span><br><span class="line"><span class="comment">#停止	./shoutdown.sh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tomcat启动成功<img src="https://www.freeimg.cn/i/2024/05/07/663a48b51cf7f.png" alt="https://www.freeimg.cn/i/2024/05/07/663a48b51cf7f.png"></p>
<p>如果防火墙8080端口开了并且阿里云安全组页开放了，这个时候就可以直接访问远程了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看firewall服务状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启、重启、关闭、firewalld.service服务</span></span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all    <span class="comment"># 查看全部信息</span></span><br><span class="line">firewall-cmd --list-ports  <span class="comment"># 只看端口信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启端口</span></span><br><span class="line">开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone <span class="comment">#作用域</span></span><br><span class="line">--add-port=80/tcp  <span class="comment">#添加端口，格式为：端口/通讯协议</span></span><br><span class="line">--permanent   <span class="comment">#永久生效，没有此参数重启后失效</span></span><br></pre></td></tr></table></figure>

<p>域名解析后，如果端口是80-http 或者443-https  可以直接访问，如果是9000 8080，就需要通过Apache或者Nginx做一下方向代理，配置文件即可，</p>
<h3 id="4-3Docker安装"><a href="#4-3Docker安装" class="headerlink" title="4.3Docker安装"></a>4.3Docker安装</h3><p>yum安装：在linux下执行，一定要联网，yum在线安装</p>
<blockquote>
<p>安装</p>
</blockquote>
<p>1.检测centos</p>
<p>cat &#x2F;etc&#x2F;redhat-release    查看服务器的系统版本信息</p>
<p>2.安装我们的准备环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install 包名	<span class="comment">#yum  install   这是安装命令</span></span><br></pre></td></tr></table></figure>

<p>3.清楚先前的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure>

<p>4.安装Docker</p>
<p>Alibaba Cloud Linux 3</p>
<ol>
<li><p>运行以下命令，添加docker-ce的dnf源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf config-manager --add-repo=https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令，安装Alibaba Cloud Linux 3专用的dnf源兼容插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf -y install dnf-plugin-releasever-adapter --repo alinux3-plus</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令，安装Docker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf -y install docker-ce --nobest</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果执行命令时，出现类似如下的报错信息，您需要执行<code>sudo dnf clean packages</code>清除软件包缓存后，重新安装docker-ce。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(8-9/12): docker-ce-24.0.7-1.el8.x86_64.rpm 38% [================- ] 8.2 MB/s | 38 MB 00:07 ETA</span><br><span class="line">The downloaded packages were saved in cache until the next successful transaction.</span><br><span class="line">You can remove cached packages by executing &#x27;dnf clean packages&#x27;.</span><br><span class="line">Error: Error downloading packages:</span><br><span class="line">containerd.io-1.6.26-3.1.el8.x86_64: Cannot download, all mirrors were already tried without success</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果执行命令时，出现类似下图的报错信息，您需要注释&#x2F;etc&#x2F;yum.repos.d下的CentOS源，注释后重新安装docker-ce。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/1286511071/p477222.png" alt="adad566"></p>
</li>
</ul>
</li>
<li><p>执行以下命令，检查Docker是否安装成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo docker -v</span><br></pre></td></tr></table></figure>

<p>如下图回显信息所示，表示Docker已安装成功。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/6489086861/p683254.png" alt="image..png"></p>
</li>
<li><p>执行以下命令，启动Docker服务，并设置开机自启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令，查看Docker是否启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure>

<p>如下图回显所示，表示Docker已启动。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/9710116861/p679571.png" alt="image..png"></p>
</li>
</ol>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OperationSystem</category>
      </categories>
      <tags>
        <tag>-Linux -OperationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2024/06/30/MysqlBase/</url>
    <content><![CDATA[<p>1.DDL</p>
<p>DDL-数据库操作</p>
<pre><code>        显示所有的数据库 show databases
        创建数据库 create database 数据库名
        使用数据库 use 数据库名
        查询当前处于哪个数据库 select   database()
        删除数据库 drop database 数据库名	
</code></pre>
<p>DDL-表操作-查询</p>
<pre><code>        查询当前数据库所有表	show tables
        查询表结构	desc 表名
        查询指定表的建表语句	show create table 表名
</code></pre>
<p>DDL-表操作-创建</p>
<pre><code>        create table 表名(
                    字段1 字段1类型[comment 字段1注释],
                    字段2 字段2类型[comment 字段2注释],
                    .......
                    字段N 字段N类型[comment 字段N注释]        该字段后面没有逗号
                      )[comment 表注释];
</code></pre>
<p>DDL-表操作-修改</p>
<pre><code>        添加字段	 alter  table 表名 add  字段名 类型(长度)
        修改数据类型 alter table 表名 modify 字段名 新数据类型()
        修改字段名和字段类型 alter table 表名 change 旧字段名 新字段名 类型(长度)
        删除字段 alter table 表名 drop 字段名
        修改表名 alter table 表名 rename to 新表名
</code></pre>
<p>DDL-表操作-删除</p>
<pre><code>        删除表 drop table[if exists] 表名
        删除指定表，并重新创建该表 truncate table 表名
</code></pre>
<p>2.DML</p>
<p>DML-添加数据 </p>
<pre><code>        1.给指定数段添加数据 insert   into 表名(字段名1,字段名2,...)values(值1，值2,...)
        2.给全部字段插入数据  insert into 表名  values (值1，值2，...)
        3.批量添加数据  	insert into 表名(字段1,字段2，...) values(值1,值2，...)
                        insert into 表名  values (值1，值2，...)
        //注意字符串和日期型数据应该包含在引号中
</code></pre>
<p>DML-修改数据</p>
<pre><code>        update 表名  set 字段名1=值1，字段名2=值2... where 条件   条件可以有也可以没有，如果没有则会修改整张表的数据
</code></pre>
<p>DML-删除数据</p>
<pre><code>        delete from 表名 where 条件  
        //delete语句不能删除某一个字段，可以用update，是字段的值=null
</code></pre>
<p>3.DQL</p>
<p>DQL-基本查询</p>
<pre><code>        1.查询多个字段  select 字段1，字段2，...from 表名、
                       select * from 表名
        2.设置别名 select 字段1[as 别名],字段2[as 别名]...from 表名
        3.去除重复记录 select  distinct 字段列表 from 表名
</code></pre>
<p>DQL-条件查询</p>
<pre><code>        1.语法  select 字段列表 from 表名  where 条件列表
        2.条件 比较运算符  大于小于等    like占位符(模糊匹配 _匹配单个字符,%匹配多个字符0) isNULL是NULl  between and 在某个范围之间 
               逻辑运算符  and或者&amp;&amp; or或者||  not或者！ 
</code></pre>
<p>DQL-聚合函数</p>
<pre><code>        1.常见聚合函数
        count 统计数量
        max 最大值
        min 最小值
        avg 平均值
        sum 求和
        2.语法 select 聚合函数(字段列表) from 表名   where 条件
        注意 null值不参与所有聚合函数运算   字段列表就是表名.字段名或者字段名
</code></pre>
<p>DQL-分组查询</p>
<pre><code>        select字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];
        
        注意:分组之后，查询的字段为聚合函数和分组字段,查询其他字段无任何意义 
        -- where和having区别:
        
        执行时机不一样: where 是分组之前进行限定，不满足where条件,则不参与分组，而having是分组之后对结果进行过滤。
        可判断的条件不一 样: where 不能对聚合函数进行判断，having 可以。
        -- 执行顺序: where &gt;聚合函数&gt; having
        
        -- 1.查询男同学和女同学各自的数学平均分
        select avg(math) from stu group by sex ;
         
        -- 注意:分组之后，查询的字段为聚合函数和分组字段,查询其他字段无任何意义 
        select sex,avg(math) from stu group by sex ;
         
        -- 2.查询男同学和女同学各自的数学平均分，以及各自人数
        select sex,avg(math),count(*) from stu group by sex ;
         
        -- 3.查询男同学和女同学各自的数学平均分，以及各自人数，要求:分数低于70分的不参与分组
        select sex,avg(math),count(*) from stu where math &gt;70 group by sex ;
         
        -- 4.查询男同学和女同学各自的数学平均分，以及各自人数，要求:分数低于70分的不参与分组，分组之后人数大于2
        select sex,avg(math),count(*) from stu where math &gt;70 group by sex having count(*) &gt; 2 ;
</code></pre>
<p>DQL—排序查询</p>
<pre><code>        SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] ..
    
            排序方式:
            
            ASC:升序排列(默认值)
            DESC: 降序排列
            注意:如果有多个排序条件，当前边的条件值一-样时, 才会根据第二条件进行排序。
</code></pre>
<p>​				<br>​				原本的数据（是按照id升序排列的）<br>​				<br>​				1.查询学生信息，按照年龄升序排列<br>​				<br>                select * from stu order by age asc ;&#x2F;&#x2F;asc可以不写，默认是升序排序</p>
<pre><code>            2.查询学生信息，按照数学成绩降序排列 
            
            select * from stu order by math desc ;
            
             3.查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列
            
            select * from stu order by math desc, english asc ;
</code></pre>
<p>DQl-分页查询</p>
<pre><code>            分页查询
            
            应用场景：当页面上的数据，一页显示不全，则需要分页显示
            
            分页查询的sql命令请求数据库服务器 —&gt; 服务器响应查询到的多条数据 —&gt; 前台页面
            
            语法：
            select 字段列表 from 表名 limit 起始索引，查询记录数
            起始索引从0开始 起始索引=(查询页码-1)*每页显示记录数
            select 查询列表
            from 表1 别名
            join 表2 别名
            on 连接条件
            where 筛选条件
            group by 分组
            having 分组后筛选
            order by 排序列表
            limit 起始条目索引，显示的条目数
</code></pre>
<p>​				<br>​				执行顺序：<br>​				<br>​				1&gt; from 子句<br>​				2&gt; join 子句<br>​				3&gt; on 子句<br>​				4&gt; where 子句<br>​				5&gt; group by 子句<br>​				6&gt; having 子句<br>​				7&gt; select 子句<br>​				8&gt; order by 子句<br>​				9&gt; limit 子句<br>​				<br>                特点：</p>
<pre><code>            起始条目索引如果不写，默认为0
            #案例1：查询员工信息表的前5条
            SELECT * FROM employees LIMIT 0,5;
            #完全等价于
            SELECT * FROM employees LIMIT 5;
            
            limit后面支持两个参数
            参数一：显示的起始条目索引
            参数二：条目数
            #案例2：查询有奖金的，且工资较高的第11名到第20名
            SELECT *
            FROM employees
            WHERE commission_pct IS NOT NULL
            ORDER BY salary DESC
            LIMIT 10,10;
            注意：分页查询中的索引用0开始
            
            公式：
            要显示的页数是page，每页显示的条目数为size
            select *
            from employees
            limit (page-1)*size,size;
</code></pre>
<p>DQL-综合练习	</p>
<pre><code>            假如有一个person表，属性有age，gender，name，id，address等
            1.查询年龄为20，21，22，23岁的女性员工信息
                select * from person  where gender=&#39;女&#39; and age in(20,21,22,23)
            2.查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工
                select * from person where sex=男 and(age between 20 and 40)and name like &#39;___&#39;
            3.统计员工表中，年龄小于60，男性员工和女性员工的人数
                select  gender,count(*) from person where age&lt;60 group by gender
            4.查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结构按年龄进行升序排序，如果年龄相同则按照入职时间降序排序
                select name,age from person  where age&lt;=35 order by age asc,entrytime desc
            5.查询性别为男，且年龄在20-40（含)以内的前五个员工信息，对查询结果按年龄升序排序，年龄相同按照入职时间降序排序
                select * where age=&#39;男&#39;and age between 20 and 40 order by age asc,entrytime desc limit 5
</code></pre>
<p>DQL-执行顺序</p>
<pre><code>            一个完整的DQL语句的语法格式：
    
                select ... from ... where ... group by ... having ... order by ..		
                执行顺序：
                select ...  		5	
                from ...   			1
                where ... 			2
                group by ... 		3
                having ... 			4
                order by ..			6
            
                1从哪张表中查，from
                2筛选出要求的信息 where
                3再进行分组 group by
                4分组后再筛选出有符合要求的信息 having
                5然后根据字段查出来 select
                6最后排序输出
</code></pre>
<p>4.DCl</p>
<p>DCL-用户管理</p>
<pre><code>        DCL:管理用户，授权
        1.管理用户
        ①添加用户
            语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
            例子：CREATE USER &#39;xiaozhi&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;
                
        ②删除用户
            语法：drop user &#39;用户名&#39;@&#39;主机名&#39;;
            例子：DROP USER &#39;xiaozhi&#39;@&#39;%&#39;;
        
        ③修改用户密码
            第一种方式：
                语法：UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;
                例子：UPDATE USER SET PASSWORD = PASSWORD(&#39;123456&#39;) WHERE USER = &#39;xiaozhi&#39;;
            第二种方式：
                语法：SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);
                例子：SET PASSWORD FOR &#39;xiaozhi&#39;@&#39;%&#39; = PASSWORD(&#39;abc&#39;);
    
             mysql数据库中忘记了root用户的密码？
                    1. cmd -- &gt; net stop mysql 停止mysql服务
                            需要管理员运行该cmd
                    2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                    3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                    4. use mysql;
                    5.flush privilleges;
                        说明：如果没有进行这个步骤进行下一步就会报错。
                    6. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
                    7. 关闭两个窗口
                    8. 打开任务管理器，手动结束mysqld.exe 的进程
                    9. 启动mysql服务
                    10. 使用新密码登录。
    
            ④查询用户
            ①使用user数据库中
            ②查询
            语法：select * from user;
    
        2.授权
        ①查询权限：
                SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;
                
        ②授予权限：
                语法：grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;
                例子：给xiaozhi用户授予所有权限，在任意数据库任意表上
                        GRANT ALL ON *.* TO &#39;xiaozhi&#39;@&#39;%&#39;;
                通配符ALL和*：ALL表示全部权限
                                *表示全部
    
        ③撤销权限：
                语法：revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;
                例子：REVOKE ALL ON *.* FROM &#39;xiaozhi&#39;@&#39;%&#39;;
    
            列子
                1.创建用户itcast，只能够在当前主机localhost访问，密码123456
                    create user &#39;itcast&#39;@&#39;localhost&#39;  identified by &#39;123456&#39;
                2.创建heima，可以在任意主机访问该数据库，密码123456
                    create &#39;heima&#39;@* identified by &#39;123456&#39;
                3.修改用户heima的访问密码为1234
                    update user set password=password(&#39;1234&#39;) where user=&#39;heima&#39;
                4.删除itcast@localhost用户
                    drop uesr &#39;itcast&#39;@&#39;localhost&#39;
</code></pre>
<p>DCL-控制权限</p>
<pre><code>        查询权限
            SHOW GREANTS FOR ‘用户名’@‘主机名’;
    
        授予权限
            GRANT 权限列表 ON 数据库名.表名 TO ‘用户名’@‘主机名’;
    
        撤销权限
            REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名’@‘主机名’;
</code></pre>
<p>函数</p>
<p>1.字符串函数</p>
<pre><code>常用字符串函数 
    1.字符串拼接 
        concat(s1,s2,s3,...)
    2.去除字符串头部和尾部的空格
        trim(str)
    3.返回从字符串str从start位置起的len个长度的字符串
        substring(str,start,len)
    4.左右填充  用字符串pad对字符串str的左右进行填充，达到n个字符串长度
        lpad(str,n,pad)
        rpad(str,n,pad)

由于业务需求变更，企业员工编号统一为五位数，目前不足五位数的向左补0，如1号员工的编号为00001
    update person set worknumber=lpad(worknumber,5,&#39;0&#39;)
        //person是表名，worknumber是字段名，l是left
</code></pre>
<p>2.数值函数</p>
<pre><code>常用数值函数
    1.cell(x) 向上取整
    2.floor(x) 向下取整
    3.mod(x 返回x/y的模
</code></pre>
<p>3.流程函数</p>
<pre><code>统计学院的成绩，展示规则如下
学员的属性有name id math chinese english  表的名字 是score
    &gt;=85优秀  &gt;=60及格  &lt;60 不及格
    select 
        id,
        name,
        (case when math &gt;85 then &#39;优秀&#39; when math &gt;60 then &#39;及格&#39; when math  &lt;60 then &#39;不及格&#39; )math,
        (case when english &gt;85 then &#39;优秀&#39; when english&gt;60 then &#39;及格&#39; when english &lt;60 then &#39;不及格&#39; )english,
        (case when chinese &gt;85 then &#39;优秀&#39; when chinese &gt;60 then &#39;及格&#39; when chinese &lt;60 then &#39;不及格&#39; )chinese
    from score;
</code></pre>
<p>约束</p>
<pre><code>1.约束的分类
    主键约束(primary key) PK
    自增长约束(auto_increment)
    非空约束(not null)
    唯一性约束(unique)
    默认约束(default)
    零填充约束(zerofill)
    外键约束(foreign key) FK
    检查约束(check(条件)) 
        实例
            create  table  user(
                    id int primary key auto_increment comment &#39;主键约束&#39;,
                    name varchar(10) not null  unique  comment &#39;非空约束和唯一性约束&#39;,
                    age int check ( age&gt;0&amp;&amp;age&lt;120 ) comment &#39;检查约束&#39;,
                    status varchar(1) default &#39;1&#39; comment&#39;默认约束&#39;,
                    gender char(1)
             )comment &#39;用户表&#39;;


2.外键约束
    作用:外键可以让两张表的数据之间建立连接，从而保证数据的一致性和完整性
    添加外键
        1.创建表的同时添加外键
                create table score(
                score int(3),
                st_id int(16),
                cs_id int(16),
                primary key(st_id,cs_id),
                FOREIGN KEY (st_id) REFERENCES student(id),
                FOREIGN KEY (cs_id) REFERENCES classes(id)
                );
                            
        2. 已经创建表了怎么办：在表的定义外进行添加
                alter table 表名 add constraint FK_ID foreign key(你的外键字段名) REFERENCES 外表表名(对应的表的主键字段名);
        3.删除外键
            alter table 表名 drop foreign key 外键名称

        4.外键删除和更新行为				
        NO ACTION	在父表中删除/更新记录时，首先检查记录中是否有外键，有则不允许删除/更新
        RESTRICT	当在父表中删除/更新记录时，首先检查记录中是否有外键,有则不允许删除/更新
        CASCADE	当在父表中删除/更新记录时，首先检查该记录是否有对应的外键，如果有，则也删除/更新外键在子表中的记录
        set NULL	当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中外键值为null
        set default	父表变更时，子表将外键列设置成一个默认的值(Innodb不支持)
</code></pre>
<p>多表查询</p>
<pre><code>    连接查询
        1.内连接  inner join：只返回两个表中连接字段相等的行。
            演示:查询每一个员工的姓名以及相关部门的名称 表结构 emp,dept 连接条件 empt.dept_id=dept.id
                select emp.name dept.name from emp,dept where  empt.dept_id=dept.id 这是隐式内连接
                select e.name d.name from emp e,dept d where  e.dept_id=dept.id  给emp和dept起了别名e和p
                select e.name d.name from emp e ineer join on e.dept_id=dept.id  给emp和dept起了别名e和p，但是这是显式内连接，且inner关键字可以删除


        2.外连接
                left join（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
                right join（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
                full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。
</code></pre>
]]></content>
      <categories>
        <category>RelationalDatabases</category>
      </categories>
      <tags>
        <tag>-DataBase -Mysql</tag>
      </tags>
  </entry>
</search>
